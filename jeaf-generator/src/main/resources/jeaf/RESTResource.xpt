«EXTENSION java::Naming»
«EXTENSION java::GeneratorCommons»
«EXTENSION java::OpenAPIFunctions»
«EXTENSION entity::ModelProperties»
«EXTENSION jeaf::RESTFunctions»
«EXTENSION java::OpenAPIFunctions»

«IMPORT uml»
«IMPORT JMM»

«DEFINE RESTResourceClass FOR RESTResource»
«FILE packagePath()+"/resource/"+name+"Resource.java" src_gen»
«getFileHeader()»
package «packageName()».resource;

«this.getJavadoc()»
«IF isRESTLibrarySpringWebMVC()»
	«IF this.getRESTPath().length > 0 || consumes.size > 0 || produces.size > 0»
	@org.springframework.web.bind.annotation.RequestMapping(
	«IF this.getRESTPath().length > 0»path = "«this.getRESTPath()»" 
	      «IF consumes.size > 0 || produces.size > 0 », 
	      «ENDIF»
	«ENDIF»
	«IF consumes.size > 0»
	 	consumes = {«FOREACH consumes AS mediaType SEPARATOR ","»"«mediaType.toOpenAPIContentType()»"«ENDFOREACH»}
		«IF produces.size > 0»,«ENDIF»
	«ENDIF»
	«IF produces.size > 0»
	 	produces = {«FOREACH produces AS mediaType SEPARATOR ","»"«mediaType.toOpenAPIContentType()»"«ENDFOREACH»}
	«ENDIF»
	)
	«ENDIF»
	@org.springframework.web.bind.annotation.RestController
«ELSE»
	@javax.ws.rs.Path("«IF this.getRESTPath().length > 0»«this.getRESTPath()»«ELSE»/«ENDIF»")
	«IF consumes.size > 0»@javax.ws.rs.Consumes(«IF consumes.size > 1»{«ENDIF»«FOREACH consumes AS mediaType SEPARATOR ","»javax.ws.rs.core.MediaType.«mediaType»«ENDFOREACH»«IF consumes.size > 1»}«ENDIF»)«ENDIF»
	«IF produces.size > 0»@javax.ws.rs.Produces(«IF produces.size > 1»{«ENDIF»«FOREACH produces AS mediaType SEPARATOR ","»javax.ws.rs.core.MediaType.«mediaType»«ENDFOREACH»«IF produces.size > 1»}«ENDIF»)«ENDIF»
«ENDIF»
«EXPAND java::Helper::GenerateDeprecationAnnotation -»
public class «name»Resource {
	
	«IF this.hasCompositeDataTypes()»
		«FOREACH this.getCompositeDataTypes() AS compositeDataType»
		/**
		 * List contains all classes that are involved in the serialization process of class «compositeDataType.name». This information is required by some serialization mechanisms for efficiency and security reasons.
		 */
		private static final List<Class<?>> «compositeDataType.name.toUpperCase()»_SERIALIZED_CLASSES;
		static {
		  java.util.List<Class<?>> lClasses = java.util.Arrays.asList(«FOREACH compositeDataType.collectSerializedClassNames() AS className SEPARATOR ", "»«className».class«ENDFOREACH»);
		  «compositeDataType.name.toUpperCase()»_SERIALIZED_CLASSES = java.util.Collections.unmodifiableList(lClasses);
		}
		«ENDFOREACH»
		
		«IF isTargetRuntimeSpring()»
			«IF isRESTLibrarySpringWebMVC()»
				/**
				 * REST interface makes usage of so called composite data types. As Spring itself is not able to do conversions from a String representation into a real object this is done in the generated REST Controller.
				 */
				private final com.anaptecs.jeaf.rest.composite.api.CompositeTypeConverter compositeTypeConverter;
			«ENDIF»
			«IF isRESTLibraryJAXRS()»
				/**
				 * REST interface makes usage of so called composite data types. As Spring itself is not able to do conversions from a String representation into a real object this is done in the generated REST Controller.
				 */
				@org.springframework.beans.factory.annotation.Autowired
				private com.anaptecs.jeaf.rest.composite.api.CompositeTypeConverter compositeTypeConverter;
			«ENDIF»
		«ENDIF»		
	«ENDIF»

	«IF isTargetRuntimeSpring()»
		«IF isRESTLibrarySpringWebMVC()»
			/**
			 * All request to this class will be delegated to {@link «this.fqn()»}.
			 */
			private final «this.fqn()» «name.toFirstLower()»;
		
			/**
			 * Initialize object.
			 * 
			 * @param p«name» Dependency on concrete {@link «this.fqn()»} implementation that should be used.
			 «IF this.hasCompositeDataTypes() -»
			 * @param pCompositeTypeConverter Composite type converter is used convert types from their string representation to a real object that can be processed internally.
			 «ENDIF -»
			 */
			public «name»Resource( «this.fqn()» p«name» «IF this.hasCompositeDataTypes()», com.anaptecs.jeaf.rest.composite.api.CompositeTypeConverter pCompositeTypeConverter«ENDIF») {
			  «name.toFirstLower()» = p«name»;
			  «IF this.hasCompositeDataTypes()»
			  compositeTypeConverter = pCompositeTypeConverter;
			  «ENDIF»
			}
		«ENDIF»
		«IF isRESTLibraryJAXRS()»
			/**
			 * All request to this class will be delegated to {@link «this.fqn()»}.
			 */
			@org.springframework.beans.factory.annotation.Autowired
			private «this.fqn()» «name.toFirstLower()»;
		«ENDIF»
	«ENDIF»
	«EXPAND RESTOperationImpl FOREACH ownedOperation.typeSelect(RESTOperation)»
	
	«IF isTargetRuntimeJEAF()»
		/**
		 * Method returns reference to service to which all REST requests will be delegated.
		 *
		 * @return «this.name» Service instance to which all requests will be delegated.
		 */
		private «this.fqn()» get«name»() {
		  return com.anaptecs.jeaf.core.api.JEAF.getService(«this.fqn()».class);
		}

		/**
		 * Method returns the composite type converter that should be used in this environment. This REST interface makes usage of so called composite data types. As Spring itself is not able to do conversions from a String representation into a real object this is done in the generated REST Controller.
		 * @return {@link CompositeTypeConverter} CompositeTypeConverter implementation that is configured to be used here. The method never returns null.
		 */
		private com.anaptecs.jeaf.rest.composite.api.CompositeTypeConverter getCompositeTypeConverter( ) {
		  return JEAF.getServiceProvider(com.anaptecs.jeaf.rest.composite.api.jeaf.CompositeTypeConverterServiceProvider.class);
		}
	«ENDIF»
}
«ENDFILE»
«ENDDEFINE»


«DEFINE RESTOperationImpl FOR RESTOperation»
	«IF isRESTLibrarySpringWebMVC()»
		«EXPAND SpringRESTControllerOperationImpl»
	«ELSE»
		«IF async == false»
			«EXPAND SyncJAXRSOperationImpl FOR this»
		«ELSE»
			«EXPAND AsyncJAXRSOperationImpl FOR this»
		«ENDIF»
	«ENDIF»	
«ENDDEFINE»

«DEFINE SyncJAXRSOperationImpl FOR RESTOperation»
	/**
	 * {@link «this.getOwningClass().fqn()»#«name»()}
	 */
	«IF path.length > 0»@javax.ws.rs.Path("«path»")«ENDIF»
	«EXPAND HTTPMethods»
	«IF consumes.size > 0»@javax.ws.rs.Consumes(«IF consumes.size > 1»{«ENDIF»«FOREACH consumes AS mediaType SEPARATOR ","»javax.ws.rs.core.MediaType.«mediaType»«ENDFOREACH»«IF consumes.size > 1»}«ENDIF»)«ENDIF»
	«IF produces.size > 0»@javax.ws.rs.Produces(«IF produces.size > 1»{«ENDIF»«FOREACH produces AS mediaType SEPARATOR ","»javax.ws.rs.core.MediaType.«mediaType»«ENDFOREACH»«IF produces.size > 1»}«ENDIF»)«ENDIF»
	«EXPAND java::Helper::GenerateDeprecationAnnotation-»
	«EXPAND java::Helper::GenerateDeprecationAnnotation FOR this.getReturnResult()-»
	public javax.ws.rs.core.Response  «name» («EXPAND RESTParameterSignature FOR this» «IF this.ownedParameter.select(e|e.hasParamCustomHeaders()).size > 0» «IF ownedParameter.select(e| e.isInputParameter() && e.isParameterSuppressed() == false).size > 0»,«ENDIF» @javax.ws.rs.core.Context javax.ws.rs.core.HttpHeaders pHeaders«ENDIF»)«getThrownExceptionsAsString()»{
	  «IF this.hasDataTypeParameters()»
	  // Convert basic type parameters into "real" objects.
	  	«FOREACH this.getDataTypeParameters() AS basicParam»
	    	«IF basicParam.type.isCompositeDataTypeForRESTResource()»
	    		«IF generatePublicObjectView()»
					«basicParam.type.fqn()» «basicParam.name» = «basicParam.type.fqn()».builder().set«basicParam.type.getCompositeDateTypePublicFieldName().toFirstUpper()»(«basicParam.name»AsBasicType).build();
	    		«ELSE»
		    		«IF isTargetRuntimeJEAF()»
		    			«basicParam.type.fqn()» «basicParam.name» = this.getCompositeTypeConverter().deserializeObject(«basicParam.name»AsBasicType, «basicParam.type.fqn()».class, «basicParam.type.name.toUpperCase()»_SERIALIZED_CLASSES);
		    		«ENDIF»
		    		«IF isTargetRuntimeSpring()»
		    			«basicParam.type.fqn()» «basicParam.name» = compositeTypeConverter.deserializeObject(«basicParam.name»AsBasicType, «basicParam.type.fqn()».class, «basicParam.type.name.toUpperCase()»_SERIALIZED_CLASSES);
		    		«ENDIF»
	    		«ENDIF»
	    	«ELSE»
	    		«IF basicParam.isMultivalued() == false»
	    			«basicParam.type.fqn()» «basicParam.name» = «basicParam.type.fqn()».builder().«basicParam.type.attribute().first().asSetter()»(«basicParam.name»AsBasicType).build();
	    		«ELSE»
	    			«basicParam.getCollectionType()»<«basicParam.type.fqn()»> «basicParam.name»;
				    if («basicParam.name»AsBasicType != null) {
				      «basicParam.name» = new «basicParam.getCollectionImplType()»<«basicParam.type.fqn()»>(«basicParam.name»AsBasicType.length);
				      for («basicParam.type.attribute().first().fqn()» lNext : «basicParam.name»AsBasicType) {
				        «basicParam.name».add(«basicParam.type.fqn()».builder().setCode(lNext).build());
				      }
				    }
				    else {
				      «basicParam.name» = «basicParam.getEmptyCollectionOperation()»;
				    }
	    		«ENDIF»
	    	«ENDIF»
	  	«ENDFOREACH»
	  «ENDIF»
	  
	  «FOREACH this.ownedParameter.select(e|e.isInputParameter() && e.isParameterSuppressed() == false && e.hasParamCustomHeaders()) AS beanParam»
	    // Add all http headers as custom headers.
	    for (java.util.Map.Entry<String, java.util.List<String>> lNextEntry : pHeaders.getRequestHeaders().entrySet()) {
	      «beanParam.name».addCustomHeader(lNextEntry.getKey(), lNextEntry.getValue().get(0));
	    }
	  «ENDFOREACH»

      // Delegate request to service.
      «IF isTargetRuntimeJEAF()»
		  «this.getOwningClass().fqn()» lService = this.get«this.getOwningClass().name»();
		  «IF getReturnTypeName() != "void"»
		  «getReturnTypeName()» lResult = lService.«this.name»(«this.asParameterListNames()»);
		  return javax.ws.rs.core.Response.status(«EXPAND StatusCode»).entity(lResult).build();
		  «ELSE»
		  lService.«this.name»(«this.asParameterListNames()»);
		  return javax.ws.rs.core.Response.status(«EXPAND StatusCode»).build();
		  «ENDIF»
	  «ENDIF»
      «IF isTargetRuntimeSpring()»
		  «IF getReturnTypeName() != "void"»
		  «getReturnTypeName()» lResult = «this.getOwningClass().name.toFirstLower()».«this.name»(«this.asParameterListNames()»);
		  return javax.ws.rs.core.Response.status(«EXPAND StatusCode»).entity(lResult).build();
		  «ELSE»
		  «this.getOwningClass().name.toFirstLower()».«this.name»(«this.asParameterListNames()»);
		  return javax.ws.rs.core.Response.status(«EXPAND StatusCode»).build();
		  «ENDIF»
	  «ENDIF»
	}
«ENDDEFINE»

«DEFINE SpringRESTControllerOperationImpl FOR RESTOperation»
	/**
	 * {@link «this.getOwningClass().fqn()»#«name»()}
	 */
	@org.springframework.web.bind.annotation.RequestMapping(
	«IF path.length > 0»path = "«path»",«ENDIF»
	«IF consumes.size > 0»consumes = {«FOREACH consumes AS mediaType SEPARATOR ","»"«mediaType.toOpenAPIContentType()»"«ENDFOREACH»},«ENDIF»
	«IF produces.size > 0»produces = {«FOREACH produces AS mediaType SEPARATOR ","»"«mediaType.toOpenAPIContentType()»"«ENDFOREACH»},«ENDIF»
	method = { «FOREACH httpMethods AS httpMethod SEPARATOR ","»org.springframework.web.bind.annotation.RequestMethod.«httpMethod»«ENDFOREACH»}
	)
	«EXPAND java::Helper::GenerateDeprecationAnnotation-»
	«EXPAND java::Helper::GenerateDeprecationAnnotation FOR this.getReturnResult()-»
	public «getReturnTypeName()»  «name» («EXPAND SpringRESTParameterSignature FOR this» «IF this.ownedParameter.select(e|e.hasParamCustomHeaders()).size > 0» «IF ownedParameter.select(e| e.isInputParameter() && e.isParameterSuppressed() == false).size > 0»,«ENDIF» @org.springframework.web.bind.annotation.RequestHeader java.util.Map<String, String> pHeaders«ENDIF»)«getThrownExceptionsAsString()»{
	  «IF this.hasBeanParameters()»
	  // Convert parameters into object as "BeanParams" are not supported by Spring Web. This way we do not pollute the service interface but "only" our REST controller.
	  «ENDIF»
	  «FOREACH this.getBeanParams() AS beanParam»
		  «beanParam.getTypeName()».Builder «beanParam.name.toLocalVar()»Builder = «beanParam.getTypeName()».builder();
		  «FOREACH beanParam.type.getAllAttributesFromHierarchy().select(e|e.isPropertySuppressed() == false) AS attribute»
		  		«IF attribute.type.isOpenAPIDataType()»
		  			«IF attribute.type.isCompositeDataTypeForRESTResource()»
		  				«IF generatePublicObjectView()»
		  					«beanParam.name.toLocalVar()»Builder.«attribute.asSetter()»(«attribute.type.fqn()».builder().set«attribute.type.attribute().first().name.toFirstUpper()»(«attribute.asParameter()»AsBasicType).build());
		  				«ELSE»
		  					«beanParam.name.toLocalVar()»Builder.«attribute.asSetter()»(compositeTypeConverter.deserializeObject(«attribute.asParameter()»AsBasicType, «attribute.type.fqn()».class, «attribute.type.name.toUpperCase()»_SERIALIZED_CLASSES));
		  				«ENDIF»
		  			«ELSE»
		  				«beanParam.name.toLocalVar()»Builder.«attribute.asSetter()»(«attribute.type.fqn()».builder().set«attribute.type.attribute().first().name.toFirstUpper()»(«attribute.asParameter()»AsBasicType).build());
		  			«ENDIF»
		  		«ELSE»
		  			«beanParam.name.toLocalVar()»Builder.«attribute.asSetter()»(«attribute.asParameter()»);
		  		«ENDIF»
		  «ENDFOREACH»
		  «beanParam.getTypeName()» «beanParam.name» = «beanParam.name.toLocalVar()»Builder.build();
		  «IF beanParam.hasParamCustomHeaders()»
			// Add custom headers.
			for (java.util.Map.Entry<String, String> lNextEntry : pHeaders.entrySet()) {
			  «beanParam.name».addCustomHeader(lNextEntry.getKey(), lNextEntry.getValue());
			}		  
		  «ENDIF»
	  «ENDFOREACH»
	  «IF this.hasDataTypeParameters()»
	  // Convert basic type parameters into "real" objects.
	  	«FOREACH this.getDataTypeParameters() AS basicParam»
	    	«IF basicParam.type.isCompositeDataTypeForRESTResource()»
	    		«IF generatePublicObjectView()»
					«basicParam.type.fqn()» «basicParam.name» = «basicParam.type.fqn()».builder().set«basicParam.type.attribute().first().name.toFirstUpper()»(«basicParam.name»AsBasicType).build();
	    		«ELSE»
	    			«basicParam.type.fqn()» «basicParam.name» = compositeTypeConverter.deserializeObject(«basicParam.name»AsBasicType, «basicParam.type.fqn()».class, «basicParam.type.name.toUpperCase()»_SERIALIZED_CLASSES);
	    		«ENDIF»
	    	«ELSE»
	    		«IF basicParam.isMultivalued() == false»
	    			«basicParam.type.fqn()» «basicParam.name» = «basicParam.type.fqn()».builder().set«basicParam.type.attribute().first().name.toFirstUpper()»(«basicParam.name»AsBasicType).build();
	    		«ELSE»
	    			«basicParam.getCollectionType()»<«basicParam.type.fqn()»> «basicParam.name»;
				    if («basicParam.name»AsBasicType != null) {
				      «basicParam.name» = new «basicParam.getCollectionImplType()»<«basicParam.type.fqn()»>(«basicParam.name»AsBasicType.length);
				      for («basicParam.type.attribute().first().fqn()» lNext : «basicParam.name»AsBasicType) {
				        «basicParam.name».add(«basicParam.type.fqn()».builder().setCode(lNext).build());
				      }
				    }
				    else {
				      «basicParam.name» = «basicParam.getEmptyCollectionOperation()»;
				    }
	    		«ENDIF»
	    	«ENDIF»
	  	«ENDFOREACH»
	  «ENDIF»
      // Delegate request to service.
	  «IF getReturnTypeName() != "void"»
	  return «this.getOwningClass().name.toFirstLower()».«this.name»(«this.asParameterListNames()»);
	  «ELSE»
	  «this.getOwningClass().name.toFirstLower()».«this.name»(«this.asParameterListNames()»);
	  «ENDIF»
	}
«ENDDEFINE»

«DEFINE AsyncJAXRSOperationImpl FOR RESTOperation»
	/**
	 * {@link «this.getOwningClass().fqn()»#«name»()}
	 */
	«IF path.length > 0»@javax.ws.rs.Path("«path»")«ENDIF»
	«EXPAND HTTPMethods»
	«IF consumes.size > 0»@javax.ws.rs.Consumes(«IF consumes.size > 1»{«ENDIF»«FOREACH consumes AS mediaType SEPARATOR ","»javax.ws.rs.core.MediaType.«mediaType»«ENDFOREACH»«IF consumes.size > 1»}«ENDIF»)«ENDIF»
	«IF produces.size > 0»@javax.ws.rs.Produces(«IF produces.size > 1»{«ENDIF»«FOREACH produces AS mediaType SEPARATOR ","»javax.ws.rs.core.MediaType.«mediaType»«ENDFOREACH»«IF produces.size > 1»}«ENDIF»)«ENDIF»
	«EXPAND java::Helper::GenerateDeprecationAnnotation -»
	«EXPAND java::Helper::GenerateDeprecationAnnotation FOR this.getReturnResult()-»
	public void  «name» (@javax.ws.rs.container.Suspended javax.ws.rs.container.AsyncResponse pAsyncResponse, @javax.ws.rs.core.Context javax.servlet.http.HttpServletRequest pRequest «IF this.hasInputParameters()»,«ENDIF» «EXPAND RESTParameterSignature FOR this»)«getThrownExceptionsAsString()»{
	    // Lookup workload manager that takes care that the system will have an optimal throughput.
	    com.anaptecs.jeaf.workload.api.WorkloadManager lWorkloadManager = com.anaptecs.jeaf.workload.api.Workload.getWorkloadManager();
	
	    // Prepare meta information about the request.
	    String lEndpointURL = pRequest.getServletPath() + pRequest.getPathInfo();
	    com.anaptecs.jeaf.workload.api.rest.RESTRequestType lRequestInfo = new com.anaptecs.jeaf.workload.api.rest.RESTRequestType(lEndpointURL, pRequest.getMethod());

     	«IF isTargetRuntimeJEAF()»
     	// Lookup service that will be called later during async processing of the request
     	«this.getOwningClass().fqn()» lService = this.get«this.getOwningClass().name»();
     	«ENDIF»
     	
	    // Hand over current request to workload manager. Depending on its strategy and the current workload the request will be either be directly executed, first queued or rejected.
	    lWorkloadManager.execute(lRequestInfo, new com.anaptecs.jeaf.workload.api.rest.RESTWorkloadErrorHandler(pAsyncResponse), new Runnable() {
			@Override
			public void run( ) {
			    try {
					«IF this.hasDataTypeParameters()»
					// Convert basic type parameters into "real" objects.
						«FOREACH this.getDataTypeParameters() AS basicParam»
							«IF basicParam.type.isCompositeDataTypeForRESTResource()»
					    		«IF generatePublicObjectView()»
									«basicParam.type.fqn()» «basicParam.name» = «basicParam.type.fqn()».builder().set«basicParam.type.getCompositeDateTypePublicFieldName().toFirstUpper()»(«basicParam.name»AsBasicType).build();
					    		«ELSE»
						    		«IF isTargetRuntimeJEAF()»
						    			«basicParam.type.fqn()» «basicParam.name» = this.getCompositeTypeConverter().deserializeObject(«basicParam.name»AsBasicType, «basicParam.type.fqn()».class, «basicParam.type.name.toUpperCase()»_SERIALIZED_CLASSES);
						    		«ENDIF»
						    		«IF isTargetRuntimeSpring()»
						    			«basicParam.type.fqn()» «basicParam.name» = compositeTypeConverter.deserializeObject(«basicParam.name»AsBasicType, «basicParam.type.fqn()».class, «basicParam.type.name.toUpperCase()»_SERIALIZED_CLASSES);
						    		«ENDIF»
					    		«ENDIF»
							«ELSE»
								«basicParam.type.fqn()» «basicParam.name» = «basicParam.type.fqn()».builder().«basicParam.type.attribute().first().asSetter()»(«basicParam.name»AsBasicType).build();
							«ENDIF»
					  	«ENDFOREACH»
					«ENDIF»
					«IF isTargetRuntimeJEAF()»
						«IF getReturnTypeName() != "void"»
						«getReturnTypeName()» lResult = lService.«this.name»(«this.asParameterListNames()»);
						javax.ws.rs.core.Response lResponseObject = javax.ws.rs.core.Response.status(«EXPAND StatusCode»).entity(lResult).build();
						«ELSE»
						lService.«this.name»(«this.asParameterListNames()»);
						javax.ws.rs.core.Response lResponseObject = javax.ws.rs.core.Response.ok().status(«EXPAND StatusCode»).build();
						«ENDIF»
					«ENDIF»
					«IF isTargetRuntimeSpring()»
						«IF getReturnTypeName() != "void"»
						«getReturnTypeName()» lResult = «this.getOwningClass().name.toFirstLower()».«this.name»(«this.asParameterListNames()»);
						javax.ws.rs.core.Response lResponseObject = javax.ws.rs.core.Response.status(«EXPAND StatusCode»).entity(lResult).build();
						«ELSE»
						«this.getOwningClass().name.toFirstLower()».«this.name»(«this.asParameterListNames()»);
						javax.ws.rs.core.Response lResponseObject = javax.ws.rs.core.Response.ok().status(«EXPAND StatusCode»).build();
						«ENDIF»
					«ENDIF»
					
			
					// Due to the asynchronous processing of the requests, the response can not be returned as return value. Therefore we make use of the defined JAX-RS mechanisms.
					pAsyncResponse.resume(lResponseObject);
			    }
				// All kinds of exceptions have to be reported to the client. Due to the asynchronous processing we have to
				// catch them here and return them to the client via class AsyncResponse.
				catch (RuntimeException e) {
					pAsyncResponse.resume(e);
				}
			}
		});
	}
«ENDDEFINE»

«DEFINE StatusCode FOR RESTOperation»
	«IF statusCode != null && statusCode.name.length > 0»
		javax.ws.rs.core.Response.Status.«getJAXRSStatusCodeName(statusCode.name)»
	«ELSE»
		javax.ws.rs.core.Response.Status.OK»
	«ENDIF»
«ENDDEFINE»

«DEFINE HTTPMethods FOR RESTOperation»
	«FOREACH httpMethods AS method»@javax.ws.rs.«method»«ENDFOREACH»
«ENDDEFINE»

«DEFINE RESTParameterSignature FOR Operation»
  «EXPAND RESTParameterDefinition FOREACH ownedParameter.select(e| e.isInputParameter() && e.isParameterSuppressed() == false) SEPARATOR ", "» 
«ENDDEFINE»

«DEFINE RESTParameterDefinition FOR Parameter»
  «IF this.isStereotypeApplied("PathParam") -»
  @javax.ws.rs.PathParam("«EXPAND java::OpenAPI::RESTParamName FOR this»")
  «ENDIF-»
  «IF this.isStereotypeApplied("HeaderParam") -»
  @javax.ws.rs.HeaderParam("«EXPAND java::OpenAPI::RESTParamName FOR this»")
  «ENDIF-»
  «IF this.isStereotypeApplied("QueryParam") -»
  @javax.ws.rs.QueryParam("«EXPAND java::OpenAPI::RESTParamName FOR this»")
  «ENDIF-»
  «IF this.isStereotypeApplied("CookieParam") -»
  @javax.ws.rs.CookieParam("«EXPAND java::OpenAPI::RESTParamName FOR this»")
  «ENDIF-»
  «IF this.isStereotypeApplied("BeanParam") -»
  @javax.ws.rs.BeanParam 
  «ENDIF-»
  «IF this.type.isStereotypeApplied("BeanParam") -»
  @javax.ws.rs.BeanParam
  «ENDIF-»
  «IF this.isParamJEAFEnumeration() && this.hasDefaultValueForEnum()»
  @javax.ws.rs.DefaultValue("«this.getDefaultValueForEnum()»")
  «ENDIF»
  «IF this.type.isBasicType() && this.hasDefaultValueForBasicType()»
  @javax.ws.rs.DefaultValue("«this.getDefaultValueForBasicType()»")
  «ENDIF»

«EXPAND java::Helper::GenerateDeprecationAnnotation»
	«IF this.type.isOpenAPIDataType() && this.isRequestBody() == false»
	  	«IF ((JMM::OpenAPIDataType) this.type).compositeDataType»
	  		String «this.name»AsBasicType
	  	«ELSE»
	  		«this.type.attribute().first().fqn()»«IF this.isMultivalued()»[]«ENDIF» «this.name»AsBasicType
	  	«ENDIF»
	«ELSE»
	  	«this.getTypeName()» «this.name»
	«ENDIF»
«ENDDEFINE»

«DEFINE SpringRESTParameterSignature FOR Operation»
  «EXPAND SpringRESTParameterDefinition FOREACH ownedParameter.select(e| e.isInputParameter() && e.isParameterSuppressed() == false) SEPARATOR ", "» 
«ENDDEFINE»

«DEFINE SpringRESTParameterDefinition FOR Parameter»
  «IF this.isPathParam() -»
  @org.springframework.web.bind.annotation.PathVariable(name = "«EXPAND java::OpenAPI::RESTParamName FOR this»", required = «this.isRequired()» «IF this.isParamJEAFEnumeration() && this.hasDefaultValueForEnum()», defaultValue = "«this.getDefaultValueForEnum()»"«ENDIF» «IF this.type.isBasicType() && this.hasDefaultValueForBasicType()», defaultValue = "«this.getDefaultValueForBasicType()»"«ENDIF»)
  «ENDIF-»
  «IF this.isHeaderParam() -»
  @org.springframework.web.bind.annotation.RequestHeader(name = "«EXPAND java::OpenAPI::RESTParamName FOR this»", required = «this.isRequired()»«IF this.isParamJEAFEnumeration() && this.hasDefaultValueForEnum()», defaultValue = "«this.getDefaultValueForEnum()»"«ENDIF» «IF this.type.isBasicType() && this.hasDefaultValueForBasicType()», defaultValue = "«this.getDefaultValueForBasicType()»"«ENDIF»)
  «ENDIF-»
  «IF this.isQueryParam() -»
  @org.springframework.web.bind.annotation.RequestParam(name = "«EXPAND java::OpenAPI::RESTParamName FOR this»", required = «this.isRequired()»«IF this.isParamJEAFEnumeration() && this.hasDefaultValueForEnum()», defaultValue = "«this.getDefaultValueForEnum()»"«ENDIF» «IF this.type.isBasicType() && this.hasDefaultValueForBasicType()», defaultValue = "«this.getDefaultValueForBasicType()»"«ENDIF»)
  «ENDIF-»
  «IF this.isCookieParam() -»
  @org.springframework.web.bind.annotation.CookieValue(name = "«EXPAND java::OpenAPI::RESTParamName FOR this»", required = «this.isRequired()»«IF this.isParamJEAFEnumeration() && this.hasDefaultValueForEnum()», defaultValue = "«this.getDefaultValueForEnum()»"«ENDIF» «IF this.type.isBasicType() && this.hasDefaultValueForBasicType()», defaultValue = "«this.getDefaultValueForBasicType()»"«ENDIF»)
  «ENDIF-»
  «IF this.isBeanParam() -»
  	«EXPAND ProcessBeanParam FOR ((Class)this.type)»
  «ENDIF-»
  «IF this.isRequestBody() -»
  @org.springframework.web.bind.annotation.RequestBody(required = «this.isRequired()»)
  «ENDIF-»

  «EXPAND java::Helper::GenerateDeprecationAnnotation»
  «IF this.isBeanParam() == false»
	  «IF this.type.isOpenAPIDataType() && this.isRequestBody() == false»
	  	«IF ((JMM::OpenAPIDataType) this.type).compositeDataType»
	  		String «this.name»AsBasicType
	  	«ELSE»
  			«this.type.attribute().first().fqn()»«IF this.isMultivalued()»[]«ENDIF» «this.name»AsBasicType
	  	«ENDIF»
	  «ELSE»
	  	«this.getTypeName()» «this.name»
	  «ENDIF»
  «ENDIF»
«ENDDEFINE»

«DEFINE ProcessBeanParam FOR Class»
	«EXPAND SpringRESTBeanParameterDefinition FOREACH this.getAllAttributesFromHierarchy().select(e|e.isPropertySuppressed() == false) SEPARATOR ","»
«ENDDEFINE»

«DEFINE SpringRESTBeanParameterDefinition FOR Property»
  «IF this.isPathParamProperty() -»
  @org.springframework.web.bind.annotation.PathVariable(name = "«EXPAND java::OpenAPI::RESTParamName FOR this»", required = «this.isRequiredProperty()» «IF this.isJEAFEnumeration() && this.hasDefaultValueForEnumProperty()», defaultValue = "«this.getDefaultValueForEnumProperty()»"«ENDIF» «IF this.type.isBasicType() && this.hasDefaultValueForBasicTypeProperty()», defaultValue = "«this.getDefaultValueForBasicTypeProperty()»"«ENDIF»)
  «ENDIF-»
  «IF this.isHeaderParamProperty() -»
  @org.springframework.web.bind.annotation.RequestHeader(name = "«EXPAND java::OpenAPI::RESTParamName FOR this»", required = «this.isRequiredProperty()»«IF this.isJEAFEnumeration() && this.hasDefaultValueForEnumProperty()», defaultValue = "«this.getDefaultValueForEnumProperty()»"«ENDIF» «IF this.type.isBasicType() && this.hasDefaultValueForBasicTypeProperty()», defaultValue = "«this.getDefaultValueForBasicTypeProperty()»"«ENDIF»)
  «ENDIF-»
  «IF this.isQueryParamProperty() -»
  @org.springframework.web.bind.annotation.RequestParam(name = "«EXPAND java::OpenAPI::RESTParamName FOR this»", required = «this.isRequiredProperty()»«IF this.isJEAFEnumeration() && this.hasDefaultValueForEnumProperty()», defaultValue = "«this.getDefaultValueForEnumProperty()»"«ENDIF» «IF this.type.isBasicType() && this.hasDefaultValueForBasicTypeProperty()», defaultValue = "«this.getDefaultValueForBasicTypeProperty()»"«ENDIF»)
  «ENDIF-»
  «IF this.isCookieParamProperty() -»
  @org.springframework.web.bind.annotation.CookieValue(name = "«EXPAND java::OpenAPI::RESTParamName FOR this»", required = «this.isRequiredProperty()»«IF this.isJEAFEnumeration() && this.hasDefaultValueForEnumProperty()», defaultValue = "«this.getDefaultValueForEnumProperty()»"«ENDIF» «IF this.type.isBasicType() && this.hasDefaultValueForBasicTypeProperty()», defaultValue = "«this.getDefaultValueForBasicTypeProperty()»"«ENDIF»)
  «ENDIF-»

  «EXPAND java::Helper::GenerateDeprecationAnnotation»
	  «IF this.type.isOpenAPIDataType() »
	  	«IF ((JMM::OpenAPIDataType) this.type).compositeDataType»
	  		String «this.asParameter()»AsBasicType
	  	«ELSE»
	  		«this.type.attribute().first().fqn()» «this.asParameter()»AsBasicType
	  	«ENDIF»
	  «ELSE»
	  	«this.fqn()»«IF this.association == null && this.isMultivalued()»[]«ENDIF» «this.asParameter()»
	  «ENDIF»
«ENDDEFINE»

