«EXTENSION java::Naming»
«EXTENSION java::GeneratorCommons»
«EXTENSION java::OpenAPIFunctions»
«EXTENSION entity::ModelProperties»
«EXTENSION jeaf::RESTFunctions»
«EXTENSION java::OpenAPIFunctions»

«EXTENSION functions::RESTResource»

«IMPORT uml»
«IMPORT JMM»

«DEFINE RESTResourceClass FOR RESTResource»
«FILE packagePath()+"/resource/"+name+"Resource.java" src_gen»
«getFileHeader()»
package «packageName()».resource;

«this.getJavadoc()»
«IF isRESTLibrarySpringWebMVC()»
	«IF this.getRESTPath().length > 0 || consumes.size > 0 || produces.size > 0»
	@org.springframework.web.bind.annotation.RequestMapping(
	«IF this.getRESTPath().length > 0»path = "«this.getRESTPath()»" 
	      «IF consumes.size > 0 || produces.size > 0 », 
	      «ENDIF»
	«ENDIF»
	«IF consumes.size > 0»
	 	consumes = {«FOREACH consumes AS mediaType SEPARATOR ","»"«mediaType.toOpenAPIContentType()»"«ENDFOREACH»}
		«IF produces.size > 0»,«ENDIF»
	«ENDIF»
	«IF produces.size > 0»
	 	produces = {«FOREACH produces AS mediaType SEPARATOR ","»"«mediaType.toOpenAPIContentType()»"«ENDFOREACH»}
	«ENDIF»
	)
	«ENDIF»
	@org.springframework.web.bind.annotation.RestController
«ELSE»
	@javax.ws.rs.Path("«IF this.getRESTPath().length > 0»«this.getRESTPath()»«ELSE»/«ENDIF»")
	«IF consumes.size > 0»@javax.ws.rs.Consumes(«IF consumes.size > 1»{«ENDIF»«FOREACH consumes AS mediaType SEPARATOR ","»javax.ws.rs.core.MediaType.«mediaType»«ENDFOREACH»«IF consumes.size > 1»}«ENDIF»)«ENDIF»
	«IF produces.size > 0»@javax.ws.rs.Produces(«IF produces.size > 1»{«ENDIF»«FOREACH produces AS mediaType SEPARATOR ","»javax.ws.rs.core.MediaType.«mediaType»«ENDFOREACH»«IF produces.size > 1»}«ENDIF»)«ENDIF»
«ENDIF»
«EXPAND java::Helper::GenerateDeprecationAnnotation -»
public class «name»Resource {
	
	«IF this.hasCompositeDataTypes()»
		«FOREACH this.getCompositeDataTypes() AS compositeDataType»
		/**
		 * List contains all classes that are involved in the serialization process of class «compositeDataType.name». This information is required by some serialization mechanisms for efficiency and security reasons.
		 */
		private static final List<Class<?>> «compositeDataType.name.toUpperCase()»_SERIALIZED_CLASSES;
		static {
		  java.util.List<Class<?>> lClasses = java.util.Arrays.asList(«FOREACH compositeDataType.collectSerializedClassNames() AS className SEPARATOR ", "»«className».class«ENDFOREACH»);
		  «compositeDataType.name.toUpperCase()»_SERIALIZED_CLASSES = java.util.Collections.unmodifiableList(lClasses);
		}
		«ENDFOREACH»
		
		«IF isTargetRuntimeSpring()»
			«IF isRESTLibrarySpringWebMVC()»
				/**
				 * REST interface makes usage of so called composite data types. As Spring itself is not able to do conversions from a String representation into a real object this is done in the generated REST Controller.
				 */
				private final com.anaptecs.jeaf.rest.composite.api.CompositeTypeConverter compositeTypeConverter;
			«ENDIF»
			«IF isRESTLibraryJAXRS()»
				/**
				 * REST interface makes usage of so called composite data types. As Spring itself is not able to do conversions from a String representation into a real object this is done in the generated REST Controller.
				 */
				@org.springframework.beans.factory.annotation.Autowired
				private com.anaptecs.jeaf.rest.composite.api.CompositeTypeConverter compositeTypeConverter;
			«ENDIF»
		«ENDIF»		
	«ENDIF»
	
	«IF this.filterCustomHeaders()»
	  «IF isTargetRuntimeSpring()»
		  «IF isRESTLibrarySpringWebMVC()»
			  /**
			   * Filter is used to provide only those headers that are configured to be processed by this REST resource.
			   */
			  private final com.anaptecs.jeaf.rest.resource.api.CustomHeaderFilter customHeaderFilter;
		  «ENDIF»
            «IF isRESTLibraryJAXRS()»
              /**
               * Filter is used to provide only those headers that are configured to be processed by this REST resource.
               */
              @org.springframework.beans.factory.annotation.Autowired
              private com.anaptecs.jeaf.rest.resource.api.CustomHeaderFilter customHeaderFilter;
            «ENDIF»
	  «ENDIF»
	«ENDIF»

	«IF isTargetRuntimeSpring()»
		«IF isRESTLibrarySpringWebMVC()»
			/**
			 * All request to this class will be delegated to {@link «this.fqn()»}.
			 */
			private final «this.fqn()» «name.toFirstLower()»;
		
			/**
			 * Initialize object.
			 * 
			 * @param p«name» Dependency on concrete {@link «this.fqn()»} implementation that should be used.
			 «IF this.hasCompositeDataTypes() -»
			 * @param pCompositeTypeConverter Composite type converter is used convert types from their string representation to a real object that can be processed internally.
			 «ENDIF -»
			 */
			public «name»Resource( «this.fqn()» p«name» «IF this.hasCompositeDataTypes()», com.anaptecs.jeaf.rest.composite.api.CompositeTypeConverter pCompositeTypeConverter«ENDIF»«IF this.filterCustomHeaders()», com.anaptecs.jeaf.rest.resource.api.CustomHeaderFilter pCustomHeaderFilter«ENDIF») {
			  «name.toFirstLower()» = p«name»;
			  «IF this.hasCompositeDataTypes()»
			  compositeTypeConverter = pCompositeTypeConverter;
			  «ENDIF»
			  «IF this.filterCustomHeaders()»
              customHeaderFilter = pCustomHeaderFilter;
			  «ENDIF»
			}
		«ENDIF»
		«IF isRESTLibraryJAXRS()»
			/**
			 * All request to this class will be delegated to {@link «this.fqn()»}.
			 */
			@org.springframework.beans.factory.annotation.Autowired
			private «this.fqn()» «name.toFirstLower()»;
		«ENDIF»
	«ENDIF»
	«EXPAND RESTOperationImpl FOREACH ownedOperation.typeSelect(RESTOperation)»
	
	«IF isTargetRuntimeJEAF()»
		/**
		 * Method returns reference to service to which all REST requests will be delegated.
		 *
		 * @return «this.name» Service instance to which all requests will be delegated.
		 */
		private «this.fqn()» get«name»() {
		  return com.anaptecs.jeaf.core.api.JEAF.getService(«this.fqn()».class);
		}

		«IF this.hasCompositeDataTypes()»
		/**
		 * Method returns the composite type converter that should be used in this environment. This REST interface makes usage of so called composite data types. As Spring itself is not able to do conversions from a String representation into a real object this is done in the generated REST Controller.
		 * @return {@link CompositeTypeConverter} CompositeTypeConverter implementation that is configured to be used here. The method never returns null.
		 */
		private com.anaptecs.jeaf.rest.composite.api.CompositeTypeConverter getCompositeTypeConverter( ) {
		  return JEAF.getServiceProvider(com.anaptecs.jeaf.rest.composite.api.jeaf.CompositeTypeConverterServiceProvider.class);
		}
		«ENDIF»
	«ENDIF»
}
«ENDFILE»
«ENDDEFINE»


«DEFINE RESTOperationImpl FOR RESTOperation»
	«IF isRESTLibrarySpringWebMVC()»
		«EXPAND SpringRESTControllerOperationImpl»
	«ELSE»
		«IF async == false»
			«EXPAND SyncJAXRSOperationImpl FOR this»
		«ELSE»
			«EXPAND AsyncJAXRSOperationImpl FOR this»
		«ENDIF»
	«ENDIF»	
«ENDDEFINE»

«DEFINE SyncJAXRSOperationImpl FOR RESTOperation»
	/**
	 * {@link «this.getOwningClass().fqn()»#«name»()}
	 */
	«IF path.length > 0»@javax.ws.rs.Path("«path»")«ENDIF»
	«EXPAND HTTPMethods»
	«IF consumes.size > 0»@javax.ws.rs.Consumes(«IF consumes.size > 1»{«ENDIF»«FOREACH consumes AS mediaType SEPARATOR ","»javax.ws.rs.core.MediaType.«mediaType»«ENDFOREACH»«IF consumes.size > 1»}«ENDIF»)«ENDIF»
	«IF produces.size > 0»@javax.ws.rs.Produces(«IF produces.size > 1»{«ENDIF»«FOREACH produces AS mediaType SEPARATOR ","»javax.ws.rs.core.MediaType.«mediaType»«ENDFOREACH»«IF produces.size > 1»}«ENDIF»)«ENDIF»
	«EXPAND java::Helper::GenerateDeprecationAnnotation-»
	«EXPAND java::Helper::GenerateDeprecationAnnotation FOR this.getReturnResult()-»
	public javax.ws.rs.core.Response  «name» («EXPAND RESTParameterSignature FOR this» «IF this.ownedParameter.select(e|e.hasParamCustomHeaders()).size > 0» «IF ownedParameter.select(e| e.isInputParameter() && e.isParameterSuppressed() == false).size > 0»,«ENDIF» @javax.ws.rs.core.Context javax.ws.rs.core.HttpHeaders pHeaders«ENDIF»)«getThrownExceptionsAsString()»{
	  «IF this.hasDataTypeParameters()»
	  // Convert basic type parameters into "real" objects.
	  	«FOREACH this.getDataTypeParameters() AS basicParam»
	    	«IF basicParam.type.isCompositeDataTypeForRESTResource()»
	    		«IF generatePublicObjectView()»
					«IF basicParam.isMultivalued() == false»
						«basicParam.type.fqn()» «basicParam.name» = «basicParam.type.fqn()».builder().set«basicParam.type.getCompositeDateTypePublicFieldName().toFirstUpper()»(«basicParam.name»AsBasicType).build();
					«ELSE»
		    			«basicParam.getCollectionType()»<«basicParam.type.fqn()»> «basicParam.name»;
					    if («basicParam.name»AsBasicType != null) {
					      «basicParam.name» = new «basicParam.getCollectionImplType()»<«basicParam.type.fqn()»>();
					      for (String lNext : «basicParam.name»AsBasicType) {
				    		«basicParam.name».add(«basicParam.type.fqn()».builder().set«basicParam.type.getCompositeDateTypePublicFieldName().toFirstUpper()»(lNext).build());
					      }
					    }
					    else {
					      «basicParam.name» = «basicParam.getEmptyCollectionOperation()»;
					    }
					«ENDIF»
	    		«ELSE»
	    			«IF basicParam.isMultivalued() == false»
			    		«IF isTargetRuntimeJEAF()»
			    			«basicParam.type.fqn()» «basicParam.name» = this.getCompositeTypeConverter().deserializeObject(«basicParam.name»AsBasicType, «basicParam.type.fqn()».class, «basicParam.type.name.toUpperCase()»_SERIALIZED_CLASSES);
			    		«ENDIF»
			    		«IF isTargetRuntimeSpring()»
			    			«basicParam.type.fqn()» «basicParam.name» = compositeTypeConverter.deserializeObject(«basicParam.name»AsBasicType, «basicParam.type.fqn()».class, «basicParam.type.name.toUpperCase()»_SERIALIZED_CLASSES);
			    		«ENDIF»
			    	«ELSE»
		    			«basicParam.getCollectionType()»<«basicParam.type.fqn()»> «basicParam.name»;
					    if («basicParam.name»AsBasicType != null) {
					      «basicParam.name» = new «basicParam.getCollectionImplType()»<«basicParam.type.fqn()»>();
					      for (String lNext : «basicParam.name»AsBasicType) {
				    		«IF isTargetRuntimeJEAF()»
				    			«basicParam.name».add(this.getCompositeTypeConverter().deserializeObject(lNext, «basicParam.type.fqn()».class, «basicParam.type.name.toUpperCase()»_SERIALIZED_CLASSES));
				    		«ENDIF»
				    		«IF isTargetRuntimeSpring()»
				    			«basicParam.name».add(compositeTypeConverter.deserializeObject(lNext, «basicParam.type.fqn()».class, «basicParam.type.name.toUpperCase()»_SERIALIZED_CLASSES));
				    		«ENDIF»
					      }
					    }
					    else {
					      «basicParam.name» = «basicParam.getEmptyCollectionOperation()»;
					    }
			    	«ENDIF»
	    		«ENDIF»
	    	«ELSE»
	    		«IF basicParam.isMultivalued() == false»
	    			«basicParam.type.fqn()» «basicParam.name» = «basicParam.type.fqn()».builder().«basicParam.type.attribute().first().asSetter()»(«basicParam.name»AsBasicType).build();
	    		«ELSE»
	    			«basicParam.getCollectionType()»<«basicParam.type.fqn()»> «basicParam.name»;
				    if («basicParam.name»AsBasicType != null) {
				      «basicParam.name» = new «basicParam.getCollectionImplType()»<«basicParam.type.fqn()»>();
				      for («basicParam.type.attribute().first().fqn()» lNext : «basicParam.name»AsBasicType) {
				        «basicParam.name».add(«basicParam.type.fqn()».builder().setCode(lNext).build());
				      }
				    }
				    else {
				      «basicParam.name» = «basicParam.getEmptyCollectionOperation()»;
				    }
	    		«ENDIF»
	    	«ENDIF»
	  	«ENDFOREACH»
	  «ENDIF»
	  
	  «FOREACH this.ownedParameter.select(e|e.isInputParameter() && e.isParameterSuppressed() == false && e.hasParamCustomHeaders()) AS beanParam»
	    // Add custom headers.
	    for (java.util.Map.Entry<String, java.util.List<String>> lNextEntry : pHeaders.getRequestHeaders().entrySet()) {
	         «IF isTargetRuntimeSpring() && filterCustomHeaders()»
	         if (customHeaderFilter.test(lNextEntry.getKey())) {
	         «ENDIF»	      
	           «beanParam.name».addCustomHeader(lNextEntry.getKey(), lNextEntry.getValue().get(0));
             «IF isTargetRuntimeSpring() && filterCustomHeaders()»
             }
             «ENDIF»          
	    }
	  «ENDFOREACH»

      // Delegate request to service.
      «IF isTargetRuntimeJEAF()»
		  «this.getOwningClass().fqn()» lService = this.get«this.getOwningClass().name»();
		  «IF getReturnTypeName() != "void"»
		  «getReturnTypeName()» lResult = lService.«this.name»(«this.asParameterListNames()»);
		  return javax.ws.rs.core.Response.status(«EXPAND StatusCode»).entity(lResult).build();
		  «ELSE»
		  lService.«this.name»(«this.asParameterListNames()»);
		  return javax.ws.rs.core.Response.status(«EXPAND StatusCode»).build();
		  «ENDIF»
	  «ENDIF»
      «IF isTargetRuntimeSpring()»
		  «IF getReturnTypeName() != "void"»
		  «getReturnTypeName()» lResult = «this.getOwningClass().name.toFirstLower()».«this.name»(«this.asParameterListNames()»);
		  return javax.ws.rs.core.Response.status(«EXPAND StatusCode»).entity(lResult).build();
		  «ELSE»
		  «this.getOwningClass().name.toFirstLower()».«this.name»(«this.asParameterListNames()»);
		  return javax.ws.rs.core.Response.status(«EXPAND StatusCode»).build();
		  «ENDIF»
	  «ENDIF»
	}
«ENDDEFINE»

«DEFINE SpringRESTControllerOperationImpl FOR RESTOperation»
	/**
	 * {@link «this.getOwningClass().fqn()»#«name»()}
	 */
	@org.springframework.web.bind.annotation.ResponseStatus(org.springframework.http.HttpStatus.«getJAXRSStatusCodeName(this.getStatusCodeName())»)
	@org.springframework.web.bind.annotation.RequestMapping(
	«IF path.length > 0»path = "«path»",«ENDIF»
	«IF consumes.size > 0»consumes = {«FOREACH consumes AS mediaType SEPARATOR ","»"«mediaType.toOpenAPIContentType()»"«ENDFOREACH»},«ENDIF»
	«IF produces.size > 0»produces = {«FOREACH produces AS mediaType SEPARATOR ","»"«mediaType.toOpenAPIContentType()»"«ENDFOREACH»},«ENDIF»
	method = { «FOREACH httpMethods AS httpMethod SEPARATOR ","»org.springframework.web.bind.annotation.RequestMethod.«httpMethod»«ENDFOREACH»}
	)
	«EXPAND java::Helper::GenerateDeprecationAnnotation-»
	«EXPAND java::Helper::GenerateDeprecationAnnotation FOR this.getReturnResult()-»
	public «getReturnTypeName()»  «name» («EXPAND SpringRESTParameterSignature FOR this» «IF this.ownedParameter.select(e|e.hasParamCustomHeaders()).size > 0» «IF ownedParameter.select(e| e.isInputParameter() && e.isParameterSuppressed() == false).size > 0»,«ENDIF» @org.springframework.web.bind.annotation.RequestHeader java.util.Map<String, String> pHeaders«ENDIF»)«getThrownExceptionsAsString()»{
	  «IF this.hasBeanParameters()»
	  // Convert parameters into object as "BeanParams" are not supported by Spring Web. This way we do not pollute the service interface but "only" our REST controller.
	  «ENDIF»
	  «FOREACH this.getBeanParams() AS beanParam»
		  «beanParam.getTypeName()».Builder «beanParam.name.toLocalVar()»Builder = «beanParam.getTypeName()».builder();
		  «FOREACH beanParam.type.getAllAttributesFromHierarchy().select(e|e.isPropertySuppressed() == false) AS attribute»
		  		«IF attribute.type.isOpenAPIDataType()»
  					// Handle bean parameter «beanParam.name».«attribute.name»
		  			«IF attribute.type.isCompositeDataTypeForRESTResource()»
		  				if(«attribute.asParameter()»AsBasicType != null) {
		  				«IF generatePublicObjectView()»
		  					«beanParam.name.toLocalVar()»Builder.«attribute.asSetter()»(«attribute.type.fqn()».builder().set«attribute.type.attribute().first().name.toFirstUpper()»(«attribute.asParameter()»AsBasicType).build());
		  				«ELSE»
		  					«IF attribute.isMultivalued() == false»
		  						«beanParam.name.toLocalVar()»Builder.«attribute.asSetter()»(compositeTypeConverter.deserializeObject(«attribute.asParameter()»AsBasicType, «attribute.type.fqn()».class, «attribute.type.name.toUpperCase()»_SERIALIZED_CLASSES));
		  					«ELSE»
		  						// Handle bean parameter «beanParam.name».«attribute.name»
		  						«IF attribute.isCollectionType()»
			  						«attribute.getCollectionType()»<«attribute.type.fqn()»> «attribute.asLocalVar()» = new «attribute.getCollectionImplType()»<«attribute.type.fqn()»>();
			  						for(String lNext : «attribute.asParameter()»AsBasicType) {
			  							«attribute.asLocalVar()».add(compositeTypeConverter.deserializeObject(lNext, «attribute.type.fqn()».class, «attribute.type.name.toUpperCase()»_SERIALIZED_CLASSES));
			  						}
			  					«ELSE»
			  						«attribute.type.fqn()»[] «attribute.asLocalVar()»  = new «attribute.type.fqn()»[«attribute.asParameter()»AsBasicType.length];
			  						for(int i = 0; i < «attribute.asParameter()»AsBasicType.length; i++) {
			  							«attribute.asLocalVar()»[i] = compositeTypeConverter.deserializeObject(«attribute.asParameter()»AsBasicType[i], «attribute.type.fqn()».class, «attribute.type.name.toUpperCase()»_SERIALIZED_CLASSES);
			  						}
			  					«ENDIF»
			  					«beanParam.name.toLocalVar()»Builder.«attribute.asSetter()»(«attribute.asLocalVar()»);
		  					«ENDIF»
		  				«ENDIF»
		  				}
		  			«ELSE»
		  				«IF attribute.isMultivalued() == false»
		  					«beanParam.name.toLocalVar()»Builder.«attribute.asSetter()»(«attribute.type.fqn()».builder().set«attribute.type.attribute().first().name.toFirstUpper()»(«attribute.asParameter()»AsBasicType).build());
		  				«ELSE»
		  					if(«attribute.asParameter()»AsBasicType != null) {
		  					«IF attribute.isCollectionType()»
		  						«attribute.getCollectionType()»<«attribute.type.fqn()»> «attribute.asLocalVar()»  = new «attribute.getCollectionImplType()»<«attribute.type.fqn()»>();
		  						for(«attribute.type.attribute().first().fqn()» lNext :  «attribute.asParameter()»AsBasicType) {
		  							«attribute.asLocalVar()».add(«attribute.type.fqn()».builder().set«attribute.type.attribute().first().name.toFirstUpper()»(lNext).build());
		  						}
		  					«ELSE»
		  						«attribute.type.fqn()»[] «attribute.asLocalVar()»  = new «attribute.type.fqn()»[«attribute.asParameter()»AsBasicType.length];
		  						for(int i = 0; i < «attribute.asParameter()»AsBasicType.length; i++) {
		  							«attribute.asLocalVar()»[i] = «attribute.type.fqn()».builder().set«attribute.type.attribute().first().name.toFirstUpper()»(«attribute.asParameter()»AsBasicType[i]).build();
		  						}
		  					«ENDIF»
		  						«beanParam.name.toLocalVar()»Builder.«attribute.asSetter()»(«attribute.asLocalVar()»);
		  					}
		  				«ENDIF»
		  			«ENDIF»
		  		«ELSE»
		  			«IF attribute.type.isAnyDateType()»
		  				// Handle bean parameter «beanParam.name».«attribute.name»
			  			«IF attribute.isMultivalued() == false»
				  			if(«attribute.asParameter()»AsBasicType != null) {
				  				«IF attribute.type.belongsToJavaTimeAPI()»
				  					«beanParam.name.toLocalVar()»Builder.«attribute.asSetter()»(«attribute.type.fqn()».parse(«attribute.asParameter()»AsBasicType));
				  				«ELSE»
									«IF attribute.type.isSQLTimestamp() || attribute.type.isSQLDate() || attribute.type.isSQLTime()»
						  				«beanParam.name.toLocalVar()»Builder.«attribute.asSetter()»(«attribute.type.fqn()».valueOf(«attribute.asParameter()»AsBasicType));
						  			«ELSE»				  						
				  						try {
				  							«IF attribute.type.isUtilDate()»
				  								java.util.Date lDate = new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX").parse(«attribute.asParameter()»AsBasicType);
				  								«beanParam.name.toLocalVar()»Builder.«attribute.asSetter()»(lDate);
						  					«ELSE»«IF attribute.type.isCalendar()»
										        java.util.Date lDate = new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX").parse(«attribute.asParameter()»AsBasicType);
										        java.util.Calendar lCalendar = Calendar.getInstance();
										        lCalendar.setTime(lDate);
						  						«beanParam.name.toLocalVar()»Builder.«attribute.asSetter()»(lCalendar);
						  					«ELSE»«ENDIF»«ENDIF»
										}
										catch (java.text.ParseException e) {
										  throw new IllegalArgumentException(e.getMessage());
										}
									«ENDIF»
				  				«ENDIF»
				  			}
			  			«ELSE»
							if(«attribute.asParameter()»AsBasicType != null) {
								«IF attribute.type.isCalendar() || attribute.type.isUtilDate()»
								try {
								«ENDIF»
								«IF attribute.isCollectionType()»
						  			«attribute.getCollectionType()»<«attribute.type.fqn()»> «attribute.asLocalVar()» = new «attribute.getCollectionImplType()»<«attribute.type.fqn()»>();
									for (int i = 0; i < «attribute.asParameter()»AsBasicType.length; i++) {
									  «IF attribute.type.belongsToJavaTimeAPI()» 
									  	«attribute.asLocalVar()».add(«attribute.type.fqn()».parse(«attribute.asParameter()»AsBasicType[i]));
									  «ELSE»
									  	«IF attribute.type.isCalendar()»
										  	java.text.SimpleDateFormat lDateFormat = new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
										  	java.util.Date lDate = lDateFormat.parse(«attribute.asParameter()»AsBasicType[i]);
									        java.util.Calendar lCalendar = Calendar.getInstance();
									        lCalendar.setTime(lDate);
					  						«attribute.asLocalVar()».add(lCalendar);
									  	«ELSE»«IF attribute.type.isUtilDate()»
										  	java.text.SimpleDateFormat lDateFormat = new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
										  	java.util.Date lDate = lDateFormat.parse(«attribute.asParameter()»AsBasicType[i]);
									  		«attribute.asLocalVar()».add(lDate);
									  	«ELSE»«IF attribute.type.isSQLTimestamp() || attribute.type.isSQLDate() || attribute.type.isSQLTime()»
									  		«attribute.asLocalVar()».add(«attribute.type.fqn()».valueOf(«attribute.asParameter()»AsBasicType[i]));
									  	«ENDIF»«ENDIF»«ENDIF»
									  «ENDIF»
									}
								«ELSE»
									«attribute.type.fqn()»[] «attribute.asLocalVar()» = new «attribute.type.fqn()»[«attribute.asParameter()»AsBasicType.length];
									for (int i = 0; i < «attribute.asParameter()»AsBasicType.length; i++) {
									  «IF attribute.type.belongsToJavaTimeAPI()» 
									  	«attribute.asLocalVar()»[i] = «attribute.type.fqn()».parse(«attribute.asParameter()»AsBasicType[i]);
									  «ELSE»
									  	«IF attribute.type.isCalendar()»
										  	java.text.SimpleDateFormat lDateFormat = new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
										  	java.util.Date lDate = lDateFormat.parse(«attribute.asParameter()»AsBasicType[i]);
									        java.util.Calendar lCalendar = Calendar.getInstance();
									        lCalendar.setTime(lDate);
					  						«attribute.asLocalVar()»[i] = lCalendar;
									  	«ELSE»«IF attribute.type.isUtilDate()»
										  	java.text.SimpleDateFormat lDateFormat = new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
										  	java.util.Date lDate = lDateFormat.parse(«attribute.asParameter()»AsBasicType[i]);
									  		«attribute.asLocalVar()»[i] = lDate;
									  	«ELSE»«IF attribute.type.isSQLTimestamp() || attribute.type.isSQLDate() || attribute.type.isSQLTime()»
									  		«attribute.asLocalVar()»[i] = «attribute.type.fqn()».valueOf(«attribute.asParameter()»AsBasicType[i]);
									  	«ENDIF»«ENDIF»«ENDIF»
									  «ENDIF»
									}
								«ENDIF»
								«beanParam.name.toLocalVar()»Builder.«attribute.asSetter()»(«attribute.asLocalVar()»);
								«IF attribute.type.isCalendar() || attribute.type.isUtilDate()»
								}
								catch (java.text.ParseException e) {
								  throw new IllegalArgumentException(e.getMessage());
								}
								«ENDIF»
							}			  			
			  			«ENDIF»
		  			«ELSE»
		  				«beanParam.name.toLocalVar()»Builder.«attribute.asSetter()»(«attribute.asParameter()»);
		  			«ENDIF»
		  		«ENDIF»
		  «ENDFOREACH»
		  «beanParam.getTypeName()» «beanParam.name» = «beanParam.name.toLocalVar()»Builder.build();
		  «IF beanParam.hasParamCustomHeaders()»
			// Add custom headers.
			for (java.util.Map.Entry<String, String> lNextEntry : pHeaders.entrySet()) {
			 «IF filterCustomHeaders()»
			 if (customHeaderFilter.test(lNextEntry.getKey())) {
			 «ENDIF»
			    «beanParam.name».addCustomHeader(lNextEntry.getKey(), lNextEntry.getValue());
             «IF filterCustomHeaders()»
             }
             «ENDIF»
			}		  
		  «ENDIF»
	  «ENDFOREACH»
	  «IF this.hasDataTypeParameters()»
	  // Convert basic type parameters into "real" objects.
	  	«FOREACH this.getDataTypeParameters() AS basicParam»
	    	«IF basicParam.type.isCompositeDataTypeForRESTResource()»
	    		«IF generatePublicObjectView()»
					// Fixed bug hopefully
					«basicParam.type.fqn()» «basicParam.name» = «basicParam.type.fqn()».builder().set«basicParam.type.getCompositeDateTypePublicFieldName().toFirstUpper()»(«basicParam.name»AsBasicType).build();
	    		«ELSE»
	    			«IF basicParam.isMultivalued() == false»
	    				«basicParam.type.fqn()» «basicParam.name» = compositeTypeConverter.deserializeObject(«basicParam.name»AsBasicType, «basicParam.type.fqn()».class, «basicParam.type.name.toUpperCase()»_SERIALIZED_CLASSES);
	    			«ELSE»
					    «basicParam.getCollectionType()»<«basicParam.type.fqn()»> «basicParam.name»;
					    if («basicParam.name»AsBasicType != null) {
					      «basicParam.name» = new «basicParam.getCollectionImplType()»<«basicParam.type.fqn()»>();
					      for (String lNext : «basicParam.name»AsBasicType) {
					        «basicParam.name».add(compositeTypeConverter.deserializeObject(lNext, «basicParam.type.fqn()».class, «basicParam.type.name.toUpperCase()»_SERIALIZED_CLASSES));
					      }
					    }
					    else {
					      «basicParam.name» = «basicParam.getEmptyCollectionOperation()»;
					    }
	    			«ENDIF»
	    		«ENDIF»
	    	«ELSE»
	    		«IF basicParam.isMultivalued() == false»
	    			«basicParam.type.fqn()» «basicParam.name» = «basicParam.type.fqn()».builder().set«basicParam.type.attribute().first().name.toFirstUpper()»(«basicParam.name»AsBasicType).build();
	    		«ELSE»
	    			«basicParam.getCollectionType()»<«basicParam.type.fqn()»> «basicParam.name»;
				    if («basicParam.name»AsBasicType != null) {
				      «basicParam.name» = new «basicParam.getCollectionImplType()»<«basicParam.type.fqn()»>();
				      for («basicParam.type.attribute().first().fqn()» lNext : «basicParam.name»AsBasicType) {
				        «basicParam.name».add(«basicParam.type.fqn()».builder().setCode(lNext).build());
				      }
				    }
				    else {
				      «basicParam.name» = «basicParam.getEmptyCollectionOperation()»;
				    }
	    		«ENDIF»
	    	«ENDIF»
	  	«ENDFOREACH»
	  «ENDIF»
	  
	  «IF this.hasDateParameters()»
	  // Convert date types into real objects.
	  	«FOREACH this.getDateParameters() AS dateParam»
  			«IF dateParam.isMultivalued() == false»
	  			«dateParam.type.fqn()» «dateParam.name»;
	  			if(«dateParam.name»AsBasicType != null) {
  				«IF dateParam.type.belongsToJavaTimeAPI()»
  					«dateParam.name» = «dateParam.type.fqn()».parse(«dateParam.name»AsBasicType);
  				«ELSE»
					«IF dateParam.type.isSQLTimestamp() || dateParam.type.isSQLDate() || dateParam.type.isSQLTime()»
						«dateParam.name» = «dateParam.type.fqn()».valueOf(«dateParam.name»AsBasicType);
					«ELSE»
						try {
							«IF dateParam.type.isUtilDate()»
								«dateParam.name» = new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX").parse(«dateParam.name»AsBasicType);
							«ELSE»«IF dateParam.type.isCalendar()»
								java.util.Date lDate = new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX").parse(«dateParam.name»AsBasicType);
								«dateParam.name» = Calendar.getInstance();
								«dateParam.name».setTime(lDate);
							«ELSE»«ENDIF»«ENDIF»
						}
						catch (java.text.ParseException e) {
							throw new IllegalArgumentException(e.getMessage());
						}
					«ENDIF»
  				«ENDIF»
	  			}
	  			else {
	  				«dateParam.name» = null;
	  			}
  			«ELSE»
	  			«dateParam.getCollectionType()»<«dateParam.type.fqn()»> «dateParam.name»;
	  			if(«dateParam.name»AsBasicType != null) {
					«IF dateParam.type.isCalendar() || dateParam.type.isUtilDate()»
					try {
					«ENDIF»
	  				«dateParam.name» = new «dateParam.getCollectionImplType()»<«dateParam.type.fqn()»>();
					for (int i = 0; i < «dateParam.name»AsBasicType.length; i++) {
					  «IF dateParam.type.belongsToJavaTimeAPI()» 
					  	«dateParam.name».add(«dateParam.type.fqn()».parse(«dateParam.name»AsBasicType[i]));
					  «ELSE»
					  	«IF dateParam.type.isCalendar()»
						  	java.text.SimpleDateFormat lDateFormat = new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
						  	java.util.Date lDate = lDateFormat.parse(«dateParam.name»AsBasicType[i]);
					        java.util.Calendar lCalendar = Calendar.getInstance();
					        lCalendar.setTime(lDate);
	  						«dateParam.name».add(lCalendar);
					  	«ELSE»«IF dateParam.type.isUtilDate()»
						  	java.text.SimpleDateFormat lDateFormat = new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
						  	java.util.Date lDate = lDateFormat.parse(«dateParam.name»AsBasicType[i]);
					  		«dateParam.name».add(lDate);
					  	«ELSE»«IF dateParam.type.isSQLTimestamp() || dateParam.type.isSQLTime() || dateParam.type.isSQLTime()»
					  		«dateParam.name».add(«dateParam.type.fqn()».valueOf(«dateParam.name»AsBasicType[i]));
					  	«ENDIF»«ENDIF»«ENDIF»
					  «ENDIF»
					}
					«IF dateParam.type.isCalendar() || dateParam.type.isUtilDate()»
					}
					catch (java.text.ParseException e) {
					  throw new IllegalArgumentException(e.getMessage());
					}
					«ENDIF»
				}
  				else {
  					«dateParam.name» = «dateParam.getEmptyCollectionOperation()»;
  				}
  			«ENDIF»
	  	«ENDFOREACH»
	  «ENDIF»
      // Delegate request to service.
	  «IF getReturnTypeName() != "void"»
	  return «this.getOwningClass().name.toFirstLower()».«this.name»(«this.asParameterListNames()»);
	  «ELSE»
	  «this.getOwningClass().name.toFirstLower()».«this.name»(«this.asParameterListNames()»);
	  «ENDIF»
	}
«ENDDEFINE»

«DEFINE AsyncJAXRSOperationImpl FOR RESTOperation»
	/**
	 * {@link «this.getOwningClass().fqn()»#«name»()}
	 */
	«IF path.length > 0»@javax.ws.rs.Path("«path»")«ENDIF»
	«EXPAND HTTPMethods»
	«IF consumes.size > 0»@javax.ws.rs.Consumes(«IF consumes.size > 1»{«ENDIF»«FOREACH consumes AS mediaType SEPARATOR ","»javax.ws.rs.core.MediaType.«mediaType»«ENDFOREACH»«IF consumes.size > 1»}«ENDIF»)«ENDIF»
	«IF produces.size > 0»@javax.ws.rs.Produces(«IF produces.size > 1»{«ENDIF»«FOREACH produces AS mediaType SEPARATOR ","»javax.ws.rs.core.MediaType.«mediaType»«ENDFOREACH»«IF produces.size > 1»}«ENDIF»)«ENDIF»
	«EXPAND java::Helper::GenerateDeprecationAnnotation -»
	«EXPAND java::Helper::GenerateDeprecationAnnotation FOR this.getReturnResult()-»
	public void  «name» (@javax.ws.rs.container.Suspended javax.ws.rs.container.AsyncResponse pAsyncResponse, @javax.ws.rs.core.Context javax.servlet.http.HttpServletRequest pRequest «IF this.hasInputParameters()»,«ENDIF» «EXPAND RESTParameterSignature FOR this»)«getThrownExceptionsAsString()»{
	    // Lookup workload manager that takes care that the system will have an optimal throughput.
	    com.anaptecs.jeaf.workload.api.WorkloadManager lWorkloadManager = com.anaptecs.jeaf.workload.api.Workload.getWorkloadManager();
	
	    // Prepare meta information about the request.
	    String lEndpointURL = pRequest.getServletPath() + pRequest.getPathInfo();
	    com.anaptecs.jeaf.workload.api.rest.RESTRequestType lRequestInfo = new com.anaptecs.jeaf.workload.api.rest.RESTRequestType(lEndpointURL, pRequest.getMethod());

     	«IF isTargetRuntimeJEAF()»
     	// Lookup service that will be called later during async processing of the request
     	«this.getOwningClass().fqn()» lService = this.get«this.getOwningClass().name»();
     	«ENDIF»
     	
	    // Hand over current request to workload manager. Depending on its strategy and the current workload the request will be either be directly executed, first queued or rejected.
	    lWorkloadManager.execute(lRequestInfo, new com.anaptecs.jeaf.workload.api.rest.RESTWorkloadErrorHandler(pAsyncResponse), new Runnable() {
			@Override
			public void run( ) {
			    try {
					«IF this.hasDataTypeParameters()»
					// Convert basic type parameters into "real" objects.
						«FOREACH this.getDataTypeParameters() AS basicParam»
							«IF basicParam.type.isCompositeDataTypeForRESTResource()»
					    		«IF generatePublicObjectView()»
									«basicParam.type.fqn()» «basicParam.name» = «basicParam.type.fqn()».builder().set«basicParam.type.getCompositeDateTypePublicFieldName().toFirstUpper()»(«basicParam.name»AsBasicType).build();
					    		«ELSE»
						    		«IF isTargetRuntimeJEAF()»
						    			«basicParam.type.fqn()» «basicParam.name» = this.getCompositeTypeConverter().deserializeObject(«basicParam.name»AsBasicType, «basicParam.type.fqn()».class, «basicParam.type.name.toUpperCase()»_SERIALIZED_CLASSES);
						    		«ENDIF»
						    		«IF isTargetRuntimeSpring()»
						    			«basicParam.type.fqn()» «basicParam.name» = compositeTypeConverter.deserializeObject(«basicParam.name»AsBasicType, «basicParam.type.fqn()».class, «basicParam.type.name.toUpperCase()»_SERIALIZED_CLASSES);
						    		«ENDIF»
					    		«ENDIF»
							«ELSE»
								«basicParam.type.fqn()» «basicParam.name» = «basicParam.type.fqn()».builder().«basicParam.type.attribute().first().asSetter()»(«basicParam.name»AsBasicType).build();
							«ENDIF»
					  	«ENDFOREACH»
					«ENDIF»
					«IF isTargetRuntimeJEAF()»
						«IF getReturnTypeName() != "void"»
						«getReturnTypeName()» lResult = lService.«this.name»(«this.asParameterListNames()»);
						javax.ws.rs.core.Response lResponseObject = javax.ws.rs.core.Response.status(«EXPAND StatusCode»).entity(lResult).build();
						«ELSE»
						lService.«this.name»(«this.asParameterListNames()»);
						javax.ws.rs.core.Response lResponseObject = javax.ws.rs.core.Response.ok().status(«EXPAND StatusCode»).build();
						«ENDIF»
					«ENDIF»
					«IF isTargetRuntimeSpring()»
						«IF getReturnTypeName() != "void"»
						«getReturnTypeName()» lResult = «this.getOwningClass().name.toFirstLower()».«this.name»(«this.asParameterListNames()»);
						javax.ws.rs.core.Response lResponseObject = javax.ws.rs.core.Response.status(«EXPAND StatusCode»).entity(lResult).build();
						«ELSE»
						«this.getOwningClass().name.toFirstLower()».«this.name»(«this.asParameterListNames()»);
						javax.ws.rs.core.Response lResponseObject = javax.ws.rs.core.Response.ok().status(«EXPAND StatusCode»).build();
						«ENDIF»
					«ENDIF»

					// Due to the asynchronous processing of the requests, the response can not be returned as return value. Therefore we make use of the defined JAX-RS mechanisms.
					pAsyncResponse.resume(lResponseObject);
			    }
				// All kinds of exceptions have to be reported to the client. Due to the asynchronous processing we have to
				// catch them here and return them to the client via class AsyncResponse.
				catch (RuntimeException e) {
					pAsyncResponse.resume(e);
				}
			}
		});
	}
«ENDDEFINE»

«DEFINE StatusCode FOR RESTOperation»
	javax.ws.rs.core.Response.Status.«getJAXRSStatusCodeName(this.getStatusCodeName())»
«ENDDEFINE»

«DEFINE HTTPMethods FOR RESTOperation»
	«FOREACH httpMethods AS method»@javax.ws.rs.«method»«ENDFOREACH»
«ENDDEFINE»

«DEFINE RESTParameterSignature FOR Operation»
  «EXPAND RESTParameterDefinition FOREACH ownedParameter.select(e| e.isInputParameter() && e.isParameterSuppressed() == false) SEPARATOR ", "» 
«ENDDEFINE»

«DEFINE RESTParameterDefinition FOR Parameter»
  «IF this.isStereotypeApplied("PathParam") -»
  @javax.ws.rs.PathParam("«EXPAND java::OpenAPI::RESTParamName FOR this»")
  «ENDIF-»
  «IF this.isStereotypeApplied("HeaderParam") -»
  @javax.ws.rs.HeaderParam("«EXPAND java::OpenAPI::RESTParamName FOR this»")
  «ENDIF-»
  «IF this.isStereotypeApplied("QueryParam") -»
  @javax.ws.rs.QueryParam("«EXPAND java::OpenAPI::RESTParamName FOR this»")
  «ENDIF-»
  «IF this.isStereotypeApplied("CookieParam") -»
  @javax.ws.rs.CookieParam("«EXPAND java::OpenAPI::RESTParamName FOR this»")
  «ENDIF-»
  «IF this.isStereotypeApplied("BeanParam") -»
  @javax.ws.rs.BeanParam 
  «ENDIF-»
  «IF this.type.isStereotypeApplied("BeanParam") -»
  @javax.ws.rs.BeanParam
  «ENDIF-»
  «IF this.isParamJEAFEnumeration() && this.hasDefaultValueForEnum()»
  @javax.ws.rs.DefaultValue("«this.getDefaultValueForEnum()»")
  «ENDIF»
  «IF this.type.isBasicType() && this.hasDefaultValueForBasicType()»
  @javax.ws.rs.DefaultValue("«this.getDefaultValueForBasicType()»")
  «ENDIF»

«EXPAND java::Helper::GenerateDeprecationAnnotation»
	«IF this.type.isOpenAPIDataType() && this.isRequestBody() == false»
	  	«IF ((JMM::OpenAPIDataType) this.type).compositeDataType»
	  		String«IF this.isMultivalued()»[]«ENDIF» «this.name»AsBasicType
	  	«ELSE»
	  		«this.type.attribute().first().fqn()»«IF this.isMultivalued()»[]«ENDIF» «this.name»AsBasicType
	  	«ENDIF»
	«ELSE»
	  	«this.getTypeName()» «this.name»
	«ENDIF»
«ENDDEFINE»

«DEFINE SpringRESTParameterSignature FOR Operation»
  «EXPAND SpringRESTParameterDefinition FOREACH ownedParameter.select(e| e.isInputParameter() && e.isParameterSuppressed() == false) SEPARATOR ", "» 
«ENDDEFINE»

«DEFINE SpringRESTParameterDefinition FOR Parameter»
  «IF this.isPathParam() -»
  @org.springframework.web.bind.annotation.PathVariable(name = "«EXPAND java::OpenAPI::RESTParamName FOR this»", required = «this.isRequired()» «IF this.isParamJEAFEnumeration() && this.hasDefaultValueForEnum()», defaultValue = "«this.getDefaultValueForEnum()»"«ENDIF» «IF this.type.isBasicType() && this.hasDefaultValueForBasicType()», defaultValue = "«this.getDefaultValueForBasicType()»"«ENDIF»)
  «ENDIF-»
  «IF this.isHeaderParam() -»
  @org.springframework.web.bind.annotation.RequestHeader(name = "«EXPAND java::OpenAPI::RESTParamName FOR this»", required = «this.isRequired()»«IF this.isParamJEAFEnumeration() && this.hasDefaultValueForEnum()», defaultValue = "«this.getDefaultValueForEnum()»"«ENDIF» «IF this.type.isBasicType() && this.hasDefaultValueForBasicType()», defaultValue = "«this.getDefaultValueForBasicType()»"«ENDIF»)
  «ENDIF-»
  «IF this.isQueryParam() -»
  @org.springframework.web.bind.annotation.RequestParam(name = "«EXPAND java::OpenAPI::RESTParamName FOR this»", required = «this.isRequired()»«IF this.isParamJEAFEnumeration() && this.hasDefaultValueForEnum()», defaultValue = "«this.getDefaultValueForEnum()»"«ENDIF» «IF this.type.isBasicType() && this.hasDefaultValueForBasicType()», defaultValue = "«this.getDefaultValueForBasicType()»"«ENDIF»)
  «ENDIF-»
  «IF this.isCookieParam() -»
  @org.springframework.web.bind.annotation.CookieValue(name = "«EXPAND java::OpenAPI::RESTParamName FOR this»", required = «this.isRequired()»«IF this.isParamJEAFEnumeration() && this.hasDefaultValueForEnum()», defaultValue = "«this.getDefaultValueForEnum()»"«ENDIF» «IF this.type.isBasicType() && this.hasDefaultValueForBasicType()», defaultValue = "«this.getDefaultValueForBasicType()»"«ENDIF»)
  «ENDIF-»
  «IF this.isBeanParam() -»
  	«EXPAND ProcessBeanParam FOR ((Class)this.type)»
  «ENDIF-»
  «IF this.isRequestBody() -»
  @org.springframework.web.bind.annotation.RequestBody(required = «this.isRequired()»)
  «ENDIF-»

  «EXPAND java::Helper::GenerateDeprecationAnnotation»
  «IF this.isBeanParam() == false»
	  «IF this.type.isOpenAPIDataType() && this.isRequestBody() == false»
	  	«IF ((JMM::OpenAPIDataType) this.type).compositeDataType»
	  		String«IF this.isMultivalued()»[]«ENDIF» «name»AsBasicType
	  	«ELSE»
  			«this.type.attribute().first().fqn()»«IF this.isMultivalued()»[]«ENDIF» «name»AsBasicType
	  	«ENDIF»
	  «ELSE»
	  	«IF this.type.isAnyDateType()»
	  		String«IF this.isMultivalued()»[]«ENDIF» «name»AsBasicType
	  	«ELSE»
	  		«this.getTypeName()» «name»
	  	«ENDIF»
	  «ENDIF»
  «ENDIF»
«ENDDEFINE»

«DEFINE ProcessBeanParam FOR Class»
	«EXPAND SpringRESTBeanParameterDefinition FOREACH this.getAllAttributesFromHierarchy().select(e|e.isPropertySuppressed() == false) SEPARATOR ","»
«ENDDEFINE»

«DEFINE SpringRESTBeanParameterDefinition FOR Property»
  «IF this.isPathParamProperty() -»
  @org.springframework.web.bind.annotation.PathVariable(name = "«EXPAND java::OpenAPI::RESTParamName FOR this»", required = «this.isRequiredProperty()» «IF this.isJEAFEnumeration() && this.hasDefaultValueForEnumProperty()», defaultValue = "«this.getDefaultValueForEnumProperty()»"«ENDIF» «IF this.type.isBasicType() && this.hasDefaultValueForBasicTypeProperty()», defaultValue = "«this.getDefaultValueForBasicTypeProperty()»"«ENDIF»)
  «ENDIF-»
  «IF this.isHeaderParamProperty() -»
  @org.springframework.web.bind.annotation.RequestHeader(name = "«EXPAND java::OpenAPI::RESTParamName FOR this»", required = «this.isRequiredProperty()»«IF this.isJEAFEnumeration() && this.hasDefaultValueForEnumProperty()», defaultValue = "«this.getDefaultValueForEnumProperty()»"«ENDIF» «IF this.type.isBasicType() && this.hasDefaultValueForBasicTypeProperty()», defaultValue = "«this.getDefaultValueForBasicTypeProperty()»"«ENDIF»)
  «ENDIF-»
  «IF this.isQueryParamProperty() -»
  @org.springframework.web.bind.annotation.RequestParam(name = "«EXPAND java::OpenAPI::RESTParamName FOR this»", required = «this.isRequiredProperty()»«IF this.isJEAFEnumeration() && this.hasDefaultValueForEnumProperty()», defaultValue = "«this.getDefaultValueForEnumProperty()»"«ENDIF» «IF this.type.isBasicType() && this.hasDefaultValueForBasicTypeProperty()», defaultValue = "«this.getDefaultValueForBasicTypeProperty()»"«ENDIF»)
  «ENDIF-»
  «IF this.isCookieParamProperty() -»
  @org.springframework.web.bind.annotation.CookieValue(name = "«EXPAND java::OpenAPI::RESTParamName FOR this»", required = «this.isRequiredProperty()»«IF this.isJEAFEnumeration() && this.hasDefaultValueForEnumProperty()», defaultValue = "«this.getDefaultValueForEnumProperty()»"«ENDIF» «IF this.type.isBasicType() && this.hasDefaultValueForBasicTypeProperty()», defaultValue = "«this.getDefaultValueForBasicTypeProperty()»"«ENDIF»)
  «ENDIF-»

  «EXPAND java::Helper::GenerateDeprecationAnnotation»
	  «IF this.type.isOpenAPIDataType() »
	  	«IF ((JMM::OpenAPIDataType) this.type).compositeDataType»
	  		String«IF this.isMultivalued()»[]«ENDIF» «this.asParameter()»AsBasicType
	  	«ELSE»
	  		«this.type.attribute().first().fqn()»«IF this.isMultivalued()»[]«ENDIF» «this.asParameter()»AsBasicType
	  	«ENDIF»
	  «ELSE»
	  	«IF this.type.isAnyDateType()»
	  		String«IF this.isMultivalued()»[]«ENDIF» «this.asParameter()»AsBasicType
	  	«ELSE»
	  		«this.fqn()»«IF this.association == null && this.isMultivalued()»[]«ENDIF» «this.asParameter()»
	  	«ENDIF»
	  «ENDIF»
«ENDDEFINE»

