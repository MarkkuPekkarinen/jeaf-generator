«EXTENSION java::Naming»
«IMPORT uml»
«IMPORT java»
«IMPORT JMM»


«DEFINE JEAFEnumTemplate FOR JEAFEnumeration»
«FILE packagePath()+"/"+name+".java" GenBase»
package «packageName()»;

/**
 * «getComment()»
 */
«EXPAND java::Helper::GenerateDeprecationAnnotation-»
«IF this.extensibleEnum == false»
public enum «name» {
«FOREACH this.ownedLiteral AS literal»
  /**
   * «literal.getComment()»
   */
  «EXPAND java::Helper::GenerateDeprecationAnnotation FOR literal -»  
  «literal.name»«IF literal != this.ownedLiteral.last()»,«ELSE»;«ENDIF»
«ENDFOREACH»

/**
 * Initialize object.
 */
private «this.name»(«this.ownedAttribute.asParameterDefinitionList()») {
  «FOREACH this.ownedAttribute AS attr»
  «attr.name» = «attr.asParameter()»;
  «ENDFOREACH»
}
«EXPAND Attribute::DoPropertyDeclaration FOREACH this.ownedAttribute»
«EXPAND Attribute::Getter FOREACH this.ownedAttribute»
«ELSE»
public class «name» {
  public static enum «name»Type {
	«FOREACH this.ownedLiteral AS literal»
	  /**
	   * «literal.getComment()»
	   */
	  «EXPAND java::Helper::GenerateDeprecationAnnotation FOR literal -»  
	  «literal.name»,
	«ENDFOREACH»
	  /**
	   * Literal UNKNOWN is used in case that an unknown literal of this enumeration is received e.g. via an external interface. 
	   */
	  UNKNOWN;
  }

  «FOREACH this.ownedLiteral AS literal»
  /**
   * «literal.getComment()»
   */
  «EXPAND java::Helper::GenerateDeprecationAnnotation FOR literal -»  
  public static final «name» «literal.name» = new «name»(«name»Type.«literal.name»);
  «ENDFOREACH»
	
	
  /**
   * Literal of the enumeration that is represented by this instance.
   */
  private «name»Type literal;
	
  /**
   * In case that the literal is unknown then also it's actual name is still available as <code>unknownLiteralName</code>
   */
  private String unknownLiteralName;
	
  /**
   * Initialize object from real enumeration literal
   * 
   * @param pLiteral Enumeration literal that should be used to initialize the extensible enumeration. The parameter must not be null.
   */
  public «name»( «name»Type pLiteral ) {
    com.anaptecs.jeaf.xfun.api.checks.Check.checkInvalidParameterNull(pLiteral, "pLiteral");
    literal = pLiteral;
    unknownLiteralName = null;
  }

  /**
   * Initialize object using the name of the literal.
   * 
   * @param pLiteralName Literal name that should be used to initialize the extensible enumeration. If the parameter is null or has an unknown literal name then a "unknown" version will be created.
   * 
   * @see «name»#isUnknownLiteral()
   */
  public «name»( String pLiteralName ) {
    try {
      literal = Enum.valueOf(«name»Type.class, pLiteralName);
      unknownLiteralName = null;
    }
    // Literal is unknown
    catch (IllegalArgumentException e) {
      literal = «name»Type.UNKNOWN;
      unknownLiteralName = pLiteralName;
    }
  }

  /**
   * Method returns the literal that is represented by this object.
   * 
   * @return {@link «name»} Literal that is represented by this object. The method never returns null.
   */
  public «name»Type getLiteral( ) {
    return literal;
  }

  /**
   * Method checks if the represented literal is actually unknown or not.
   * 
   * @return boolean Method returns true if this object represents an unknown literal.
   */
  public boolean isUnknownLiteral( ) {
    return literal == «name»Type.UNKNOWN;
  }

  /**
   * Method returns the actual name of the unknown literal
   * 
   * @return {@link String} Name of the unknown literal or null in case that the literal is known.
   */
  public String getUnknownLiteralName( ) {
    return unknownLiteralName;
  }

  /**
   * {@link Object#hashCode()}
   */
  @Override
  public int hashCode( ) {
    int lHashCode;
    if (this.isUnknownLiteral() == true) {
      lHashCode = unknownLiteralName.hashCode();
    }
    else {
      lHashCode = literal.hashCode();
    }
    return lHashCode;
  }

  /**
   * {@link Object#equals(Object)}
   */
  @Override
  public boolean equals( Object pObject ) {
    boolean lEquals;
    if (pObject != null) {
      if (this == pObject) {
        lEquals = true;
      }
      // Passed object is of same type
      else if (pObject instanceof «name») {
        «name» lEnum = («name») pObject;

        // Compare if unknown literal is the same
        if (this.isUnknownLiteral() && lEnum.isUnknownLiteral()) {
          lEquals = this.unknownLiteralName.equals(lEnum.unknownLiteralName);
        }
        // Compare based on literals
        else {
          lEquals = this.literal == lEnum.literal;
        }
      }
      // Passed object is of different type
      else {
        lEquals = false;
      }
    }
    // Passed object is null.
    else {
      lEquals = false;
    }
    return lEquals;
  }
«ENDIF»
}
«ENDFILE»
«ENDDEFINE»