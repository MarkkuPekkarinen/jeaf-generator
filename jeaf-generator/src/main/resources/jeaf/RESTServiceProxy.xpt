«EXTENSION java::GeneratorCommons»
«EXTENSION java::Naming»
«EXTENSION jeaf::RESTFunctions»
«EXTENSION java::OpenAPIFunctions»

«IMPORT uml»
«IMPORT JMM»

«DEFINE GenerateRESTServiceProxy FOR RESTResource»
  «IF isTargetRuntimeSpring()»
  	«EXPAND GenerateRESTServiceProxySpring»
  «ENDIF»
  «IF isTargetRuntimeJEAF()»
  	«EXPAND GenerateRESTProxyServiceProviderInterface»
  	«EXPAND GenerateRESTProxyServiceProviderFactory»
  	«EXPAND GenerateRESTProxyServiceProviderImpl»
  «ENDIF»
   
«ENDDEFINE»

«DEFINE GenerateRESTProxyServiceProviderInterface FOR RESTResource»
«FILE packagePath()+"/restproxy/"+name+"RESTProxyServiceProvider.java" src_gen»
«getFileHeader()»
package «packageName()».restproxy;

/**
 * Service Provider Interface is generated so that a proxy for a REST Resource can be provided as JEAF Service Provider.
 */
public interface «name»RESTProxyServiceProvider extends com.anaptecs.jeaf.core.api.ServiceProvider {
  «EXPAND JEAFOperation::InterfaceOperation FOREACH ownedOperation»
}
«ENDFILE»
«ENDDEFINE»

«DEFINE GenerateRESTProxyServiceProviderFactory FOR RESTResource»
«FILE packagePath()+"/restproxy/"+name+"RESTProxyServiceProviderFactory.java" src_gen»
«getFileHeader()»
package «packageName()».restproxy;

import com.anaptecs.jeaf.core.api.ServiceProvider;
import com.anaptecs.jeaf.core.spi.ServiceProviderImplementation;
import com.anaptecs.jeaf.core.servicechannel.api.ServiceProviderFactory;

/**
 * This class is the factory class the service provider implementation «name»RESTProxyServiceProviderImpl().
 * 
 * «getComment()»
 */
@com.anaptecs.jeaf.core.annotations.ServiceProviderFactory
public final class «name»RESTProxyServiceProviderFactory extends ServiceProviderFactory {
  /**
   * Initialize object. No actions have to be performed.
   */
  public «name»RESTProxyServiceProviderFactory( ) {
    // Nothing to do.
  }

  /**
   * Method creates a new instance of the service provider.
   * 
   * @return {@link ServiceProviderImplementation} Instance of service provider. The method never returns null.
   * 
   * @see com.anaptecs.jeaf.core.servicechannel.api.ServiceProviderFactory#createServiceProviderImplementation()
   */
  public ServiceProviderImplementation createServiceProviderImplementation( ) {
    return new «name»RESTProxyServiceProviderImpl();
  }

  /**
   * Method returns the interface of the service provider created by this factory.
   * 
   * @return Class Class object of interface that belongs to the service provider that is created by this factory. The
   * method never returns null.
   * 
   * @see com.anaptecs.jeaf.core.servicechannel.api.ServiceProviderFactory#getServiceProviderInterface()
   */
  public Class<? extends ServiceProvider> getServiceProviderInterface( ) {
    return «packageName()».restproxy.«name»RESTProxyServiceProvider.class;
  }
}
«ENDFILE»
«ENDDEFINE»

«DEFINE GenerateRESTProxyServiceProviderImpl FOR RESTResource»
«FILE packagePath()+"/restproxy/"+name+"RESTProxyServiceProviderImpl.java" src_gen»
«getFileHeader()»
package «packageName()».restproxy;

import com.anaptecs.jeaf.core.api.ServiceProvider;
import com.anaptecs.jeaf.core.spi.ServiceProviderImplementation;
import com.anaptecs.jeaf.core.servicechannel.api.ServiceProviderFactory;

/**
 * Class implements a service provider that acts as proxy for REST service «name».
 */
public final class «name»RESTProxyServiceProviderImpl implements com.anaptecs.jeaf.core.spi.ServiceProviderImplementation, «packageName()».restproxy.«name»RESTProxyServiceProvider {
  /**
   * Reference to the object that identifies this component. The reference is never null.
   */
  private static final com.anaptecs.jeaf.xfun.api.common.ComponentID COMPONENT_ID;

  /**
   * Static initializer is used to create the components ComponentID object and its trace object.
   */
  static {
    // Create Component ID and trace object.
    Package lBasePackage = «name»RESTProxyServiceProviderImpl.class.getPackage();
    COMPONENT_ID = new com.anaptecs.jeaf.xfun.api.common.ComponentID("«name»RESTProxyServiceProviderImpl", lBasePackage.getName());
  }

  /**
   * REST request executor is used to send REST request to the proxied REST resource. Depending on the Spring
   * configuration the matching implementation will be injected here.
   */
  @com.anaptecs.jeaf.core.annotations.JEAFServiceProvider
  private com.anaptecs.jeaf.rest.executor.api.jeaf.RESTRequestExecutorServiceProvider requestExecutor;
  
  /**
   * Determine configuration of the service provider implementation and initialize httpo client to call REST service. 
   */
  @Override
  public void initialize( ) {
    // Nothing to do.
  }
  
  /**
   * Method checks state of this service provider implementation.
   * 
   * @return {@link HealthCheckResult} Result of the check.
   */
  @Override
  public com.anaptecs.jeaf.xfun.api.health.HealthCheckResult check( com.anaptecs.jeaf.xfun.api.health.CheckLevel pLevel ) {
    return null;
  }
  
  «EXPAND SpringRESTProxyOperationOperation(this) FOREACH ownedOperation.typeSelect(RESTOperation)»
}
«ENDFILE»
«ENDDEFINE»



«DEFINE GenerateRESTServiceProxySpring FOR RESTResource»
«FILE packagePath()+"/restproxy/"+name+"RESTProxy.java" src_gen»
«getFileHeader()»
package «packageName()».restproxy;

/**
 * Class implements a proxy for an REST Service. The proxy is implemented as Spring services. This way to developers it
 * looks like a plain Spring Service.
 * 
 * This implementation deals with everything that is required to call the external REST service including the following
 * things:
 * <ul>
 * <li>Serialization / deserialization between Java and JSON</li>
 * <li>Proper connection pooling and timeouts for HTTP requests</li>
 * <li>Proper setting of HTTP header</li>
 * <li>Circuit breaker in case of availabilities problems of the REST service</li>
 * </ul>
 * 
 * However, as an transactional context can not be propagated to another REST resource developers still have to take care
 * about proper transaction handling if needed.
 */
@org.springframework.stereotype.Service
public class «name»RESTProxy implements «this.fqn()» {
  /**
   * REST request executor is used to send REST request to the proxied REST resource. Depending on the Spring
   * configuration the matching implementation will be injected here.
   */
  private final com.anaptecs.jeaf.rest.executor.api.RESTRequestExecutor requestExecutor;

  /**
   * Initialize object.
   * 
   * @param pRequestExecutor Dependency on concrete {@link RESTRequestExecutor} implementation that should be used.
   */
  public «name»RESTProxy( com.anaptecs.jeaf.rest.executor.api.RESTRequestExecutor pRequestExecutor ) {
    requestExecutor = pRequestExecutor;
  }

  «EXPAND SpringRESTProxyOperationOperation(this) FOREACH ownedOperation.typeSelect(RESTOperation)»
}
«ENDFILE»
«ENDDEFINE»


«DEFINE JEAFRESTProxyOperationOperation(RESTResource service) FOR RESTOperation»
    «this.getJavadoc()» 
    «EXPAND java::Helper::GenerateDeprecationAnnotation-»
    «EXPAND java::Helper::GenerateDeprecationAnnotation FOR this.getReturnResult() -»
    @Override
	«visibility» «getReturnTypeName()» «name» («EXPAND jeaf::JEAFOperation::ParameterSignatureNoValidationAnnotation»)«getThrownExceptionsAsString()» {
	«IF isTargetRuntimeSpring() && this.hasRequestBody()»
    java.net.URI lRequestURI = null;
    try {
	«ENDIF»
		// Create builder for «this.httpMethods.selectFirst(e|e!=null)» request
		org.apache.hc.core5.http.io.support.ClassicRequestBuilder lRequestBuilder = ClassicRequestBuilder.«this.httpMethods.toList().get(0).toString().toLowerCase()»();
		
	    // Build URI of request
	    StringBuilder lURIBuilder = new StringBuilder();
	    lURIBuilder.append(configuration.getExternalServiceURL());
	    «IF service.path.length > 0»
	    lURIBuilder.append("«service.path»");
	    «ENDIF»
	    «IF this.path.length > 0»
	    	lURIBuilder.append('/');
	    	«FOREACH splitRESTPath(this.path, this.getAllPathParams(), this.getAllPathParamNamnes()) AS pathPart»
	    	lURIBuilder.append(«pathPart»);
	    	«ENDFOREACH»
	    «ENDIF»
	    lRequestBuilder.setUri(lURIBuilder.toString());
	    
	   «IF this.getQueryParams().size > 0 || this.getBeanParams().type.getAllAttributesFromHierarchy().typeSelect(JMM::QueryParam).size > 0»
	   // Add query parameter(s) to request
	   «ENDIF»
	   
    	«FOREACH this.getQueryParams() AS queryParam »
    	«IF queryParam.type.isPrimitiveType() && queryParam.isMultivalued()==false»
    	lRequestBuilder.addParameter("«queryParam.getRESTQueryParamName()»", String.valueOf(«queryParam.name»));
    	«ELSE»
    	if(«queryParam.name» != null) {
    	«IF queryParam.type.isStringType()»
    	lRequestBuilder.addParameter("«queryParam.getRESTQueryParamName()»", «queryParam.name»);
    	«ELSE»
    	«IF queryParam.type.isAnyDateType()»
    	lRequestBuilder.addParameter("«queryParam.getRESTQueryParamName()»", «EXPAND DateConversion FOR queryParam»);
    	«ELSE»
    	lRequestBuilder.addParameter("«queryParam.getRESTQueryParamName()»", «queryParam.name».toString());
    	«ENDIF»
    	«ENDIF»
    	}
    	«ENDIF»
    	«ENDFOREACH»

    	«FOREACH this.getBeanParams() AS beanParam»
    		«IF beanParam.type.getAllAttributesFromHierarchy().typeSelect(JMM::QueryParam).size > 0»
    		if(«beanParam.name» != null) {
    		«ENDIF»
    		«FOREACH beanParam.type.getAllAttributesFromHierarchy().typeSelect(JMM::QueryParam) AS queryParam»
		    	«IF queryParam.type.isPrimitiveType() && queryParam.isMultivalued() == false»
		    	lRequestBuilder.addParameter("«queryParam.getRESTQueryParamName()»", String.valueOf(«beanParam.name».«queryParam.asGetter()»()));
		    	«ELSE»
		    	if(«beanParam.name».«queryParam.asGetter()»() != null) {
		    	«IF queryParam.type.isStringType()»
		    	lRequestBuilder.addParameter("«queryParam.getRESTQueryParamName()»", «beanParam.name».«queryParam.asGetter()»());
		    	«ELSE»«IF queryParam.type.isAnyDateType()»
		    	lRequestBuilder.addParameter("«queryParam.getRESTQueryParamName()»", «EXPAND DateConversionForBeanParam(beanParam) FOR queryParam»);
		    	«ELSE»
		    	lRequestBuilder.addParameter("«queryParam.getRESTQueryParamName()»", «beanParam.name».«queryParam.asGetter()»().toString());
		    	«ENDIF»«ENDIF»
		    	}
		    	«ENDIF»
    		«ENDFOREACH»
    		«IF beanParam.type.getAllAttributesFromHierarchy().typeSelect(JMM::QueryParam).size > 0»
		    }
    		«ENDIF»
    	«ENDFOREACH»

	    «IF isTargetRuntimeSpring() && this.hasRequestBody()»
	    lRequestURI = lRequestBuilder.getUri();
	    «ENDIF»
	    
		// Set HTTP header(s)
		lRequestBuilder.setHeader(org.apache.hc.core5.http.HttpHeaders.ACCEPT, org.apache.hc.core5.http.ContentType.APPLICATION_JSON.getMimeType());
		«FOREACH this.getHeaderParams() AS headerParam»
			«IF headerParam.type.isPrimitiveType() == false»
			if («headerParam.name» != null) {
			«ENDIF»
			lRequestBuilder.setHeader("«headerParam.getRESTHeaderParamName()»", «EXPAND HeaderParamValueAccessor FOR headerParam»);
			«IF headerParam.type.isPrimitiveType() == false»
			}
			else {
			lRequestBuilder.setHeader("«headerParam.getRESTHeaderParamName()»", null);
			}
			«ENDIF»
		«ENDFOREACH»

    	«FOREACH this.getBeanParams() AS beanParam»
    		«IF beanParam.type.getAllAttributesFromHierarchy().typeSelect(JMM::HeaderParam).size > 0»
    		if(«beanParam.name» != null) {
    		«ENDIF»
    		«FOREACH beanParam.type.getAllAttributesFromHierarchy().typeSelect(JMM::HeaderParam) AS headerParam»
				«IF headerParam.type.isPrimitiveType() == false»
				if («beanParam.name».«headerParam.asGetter()»() != null) {
				«ENDIF»
		    	lRequestBuilder.setHeader("«headerParam.getRESTHeaderParamName()»", «EXPAND HeaderParamValueAccessorForBeanParam(beanParam) FOR headerParam»);
				«IF headerParam.type.isPrimitiveType() == false»
				}
				else {
				lRequestBuilder.setHeader("«headerParam.getRESTHeaderParamName()»", null);
				}
				«ENDIF»
    		«ENDFOREACH»
    		«IF beanParam.type.getAllAttributesFromHierarchy().typeSelect(JMM::HeaderParam).size > 0»
    		}
    		«ENDIF»
    	«ENDFOREACH»
    	
    	«IF this.hasCookieParams()»
	    	// Handle cookie parameters
	    	org.apache.hc.client5.http.cookie.BasicCookieStore lCookieStore = new BasicCookieStore();
	    	org.apache.hc.core5.http.protocol.HttpContext lLocalContext = new org.apache.hc.core5.http.protocol.BasicHttpContext();
	    	lLocalContext.setAttribute(org.apache.hc.client5.http.protocol.HttpClientContext.COOKIE_STORE, lCookieStore);
			String lCookieDomain = configuration.getCookieDomain(); 
			String lCookiePath = configuration.getCookiePath(); 
	    	«FOREACH this.getCookieParams() AS cookieParam»
	    	«IF cookieParam.type.isPrimitiveType() == false»
			if («cookieParam.name» != null) {
			«ENDIF»
	    	org.apache.hc.client5.http.impl.cookie.BasicClientCookie l«cookieParam.name.toFirstUpper()»Cookie = new BasicClientCookie("«cookieParam.getRESTCookieParamName()»", «EXPAND CookieParamValueAccessor FOR cookieParam»);
			if(lCookieDomain != null) {
			  l«cookieParam.name.toFirstUpper()»Cookie.setDomain(lCookieDomain);
			}
			if(lCookiePath != null) {
			  l«cookieParam.name.toFirstUpper()»Cookie.setPath(lCookiePath);
			}
			lCookieStore.addCookie(l«cookieParam.name.toFirstUpper()»Cookie);
	    	«IF cookieParam.type.isPrimitiveType() == false»
			}
			«ENDIF»
	    	«ENDFOREACH»
	    	«FOREACH this.getBeanParams() AS beanParam»
	    		«IF beanParam.type.getAllAttributesFromHierarchy().typeSelect(JMM::CookieParam).size > 0»
	    		if(«beanParam.name» != null) {
	    		«ENDIF»	    		
	    		«FOREACH beanParam.type.getAllAttributesFromHierarchy().typeSelect(JMM::CookieParam) AS cookieParam»
					«IF cookieParam.type.isPrimitiveType() == false»
					if («beanParam.name».«cookieParam.asGetter()»() != null) {
					«ENDIF»
			    	org.apache.hc.client5.http.impl.cookie.BasicClientCookie l«cookieParam.name.toFirstUpper()»Cookie = new BasicClientCookie("«cookieParam.getRESTCookieParamName()»", «EXPAND CookieParamValueAccessorForBeanParam(beanParam) FOR cookieParam»);
					if(lCookieDomain != null) {
					  l«cookieParam.name.toFirstUpper()»Cookie.setDomain(lCookieDomain);
					}
					if(lCookiePath != null) {
					  l«cookieParam.name.toFirstUpper()»Cookie.setPath(lCookiePath);
					}
					lCookieStore.addCookie(l«cookieParam.name.toFirstUpper()»Cookie);
					«IF cookieParam.type.isPrimitiveType() == false»
					}
					«ENDIF»
	    		«ENDFOREACH»
	    		«IF beanParam.type.getAllAttributesFromHierarchy().typeSelect(JMM::CookieParam).size > 0»
	    		}
	    		«ENDIF»	    		
	    	«ENDFOREACH»
    	«ENDIF»
	    
	    «FOREACH this.getRequestBodyParameters() AS body»
	    // Convert parameter «body.name» into request body.
	    «IF isTargetRuntimeJEAF()»
	    String lRequestBody = com.anaptecs.jeaf.json.api.JSONTools.getJSONTools().writeObjectToString(«body.name»);
	    «ENDIF»
	    «IF isTargetRuntimeSpring()»
	    String lRequestBody = objectMapper.writeValueAsString(«body.name»);
	    «ENDIF»
	    lRequestBuilder.setEntity(lRequestBody, ContentType.APPLICATION_JSON);
	    «ENDFOREACH»

		«IF getReturnTypeName() != "void"»
		// Execute request and return result.
		«ELSE»
		// Execute request.
		«ENDIF»
		org.apache.hc.core5.http.ClassicHttpRequest lRequest = lRequestBuilder.build();
		
		«IF getReturnTypeName() != "void"»
			«IF this.getReturnResult().isMultivalued() == false»
			return httpClient.executeSingleObjectResultRequest(lRequest, «IF this.hasCookieParams()»lLocalContext«ELSE»null«ENDIF», «this.getHTTPStatusCode()», «this.getReturnResult().type.fqn()».class);
			«ELSE»
		    «getReturnTypeName()» lResult = httpClient.executeCollectionResultRequest(lRequest, «IF this.hasCookieParams()»lLocalContext«ELSE»null«ENDIF», «this.getHTTPStatusCode()», «this.getReturnResult().getCollectionType()».class, «this.getReturnResult().type.fqn()».class);
		    if (lResult == null) {
		      lResult = java.util.Collections.emptyList();
		    }
		    return lResult;
			«ENDIF»
		«ELSE»
		    httpClient.executeNoResponseContentRequest(lRequest, «IF this.hasCookieParams()»lLocalContext«ELSE»null«ENDIF», «this.getHTTPStatusCode()»);
		«ENDIF»
	«IF isTargetRuntimeSpring() && this.hasRequestBody()»
    }
    catch (java.io.IOException e) {
      logger.error("Unable to serialize object(s) to JSON.", e);
      org.zalando.problem.ProblemBuilder lProblemBuilder = org.zalando.problem.Problem.builder();
      lProblemBuilder.withStatus(org.zalando.problem.Status.INTERNAL_SERVER_ERROR);
      lProblemBuilder.withType(lRequestURI);
      lProblemBuilder.withDetail(e.getMessage());
      throw lProblemBuilder.build();
    }
    «ENDIF»
	}
«ENDDEFINE»






«DEFINE SpringRESTProxyOperationOperation(RESTResource service) FOR RESTOperation»
    «this.getJavadoc()» 
    «EXPAND java::Helper::GenerateDeprecationAnnotation-»
    «EXPAND java::Helper::GenerateDeprecationAnnotation FOR this.getReturnResult() -»
    @Override
	«visibility» «getReturnTypeName()» «name» («EXPAND jeaf::JEAFOperation::ParameterSignatureNoValidationAnnotation»)«getThrownExceptionsAsString()» {
		// Create builder for «this.httpMethods.selectFirst(e|e!=null)» request
		com.anaptecs.jeaf.rest.executor.api.RESTRequest.Builder lRequestBuilder = com.anaptecs.jeaf.rest.executor.api.RESTRequest.builder(«service.fqn()».class, com.anaptecs.jeaf.rest.executor.api.HttpMethod.«this.httpMethods.selectFirst(e|e!=null)», com.anaptecs.jeaf.rest.executor.api.ContentType.JSON);
		
	    // Build path of request
	    StringBuilder lPathBuilder = new StringBuilder();
	    «IF service.path.length > 0»
	    lPathBuilder.append("«service.path»");
	    «ENDIF»
	    «IF this.path.length > 0»
	    	lPathBuilder.append('/');
	    	«FOREACH splitRESTPath(this.path, this.getAllPathParams(), this.getAllPathParamNamnes()) AS pathPart»
	    	lPathBuilder.append(«pathPart»);
	    	«ENDFOREACH»
	    «ENDIF»
	    lRequestBuilder.setPath(lPathBuilder.toString());
	    
	   «IF this.getQueryParams().size > 0 || this.getBeanParams().type.getAllAttributesFromHierarchy().typeSelect(JMM::QueryParam).size > 0»
	   // Add query parameter(s) to request
	   «ENDIF»
	   
    	«FOREACH this.getQueryParams() AS queryParam »
    	«IF queryParam.type.isPrimitiveType() && queryParam.isMultivalued()==false»
    	lRequestBuilder.addQueryParam("«queryParam.getRESTQueryParamName()»", String.valueOf(«queryParam.name»));
    	«ELSE»
    	if(«queryParam.name» != null) {
    	«IF queryParam.type.isStringType()»
    	lRequestBuilder.addQueryParam("«queryParam.getRESTQueryParamName()»", «queryParam.name»);
    	«ELSE»
    	«IF queryParam.type.isAnyDateType()»
    	lRequestBuilder.addQueryParam("«queryParam.getRESTQueryParamName()»", «EXPAND DateConversion FOR queryParam»);
    	«ELSE»
    	lRequestBuilder.addQueryParam("«queryParam.getRESTQueryParamName()»", «queryParam.name».toString());
    	«ENDIF»
    	«ENDIF»
    	}
    	«ENDIF»
    	«ENDFOREACH»

    	«FOREACH this.getBeanParams() AS beanParam»
    		«IF beanParam.type.getAllAttributesFromHierarchy().typeSelect(JMM::QueryParam).size > 0»
    		if(«beanParam.name» != null) {
    		«ENDIF»
    		«FOREACH beanParam.type.getAllAttributesFromHierarchy().typeSelect(JMM::QueryParam) AS queryParam»
		    	«IF queryParam.type.isPrimitiveType() && queryParam.isMultivalued() == false»
		    	lRequestBuilder.addQueryParam("«queryParam.getRESTQueryParamName()»", String.valueOf(«beanParam.name».«queryParam.asGetter()»()));
		    	«ELSE»
		    	if(«beanParam.name».«queryParam.asGetter()»() != null) {
		    	«IF queryParam.type.isStringType()»
		    	lRequestBuilder.addQueryParam("«queryParam.getRESTQueryParamName()»", «beanParam.name».«queryParam.asGetter()»());
		    	«ELSE»«IF queryParam.type.isAnyDateType()»
		    	lRequestBuilder.addQueryParam("«queryParam.getRESTQueryParamName()»", «EXPAND DateConversionForBeanParam(beanParam) FOR queryParam»);
		    	«ELSE»
		    	lRequestBuilder.addQueryParam("«queryParam.getRESTQueryParamName()»", «beanParam.name».«queryParam.asGetter()»().toString());
		    	«ENDIF»«ENDIF»
		    	}
		    	«ENDIF»
    		«ENDFOREACH»
    		«IF beanParam.type.getAllAttributesFromHierarchy().typeSelect(JMM::QueryParam).size > 0»
		    }
    		«ENDIF»
    	«ENDFOREACH»

		«IF this.getHeaderParams().size > 0 || this.getBeanParams().type.getAllAttributesFromHierarchy().typeSelect(JMM::HeaderParam).size > 0»
		// Set HTTP header(s)
		«FOREACH this.getHeaderParams() AS headerParam»
			«IF headerParam.type.isPrimitiveType() == false»
			if («headerParam.name» != null) {
			«ENDIF»
			lRequestBuilder.setHeader("«headerParam.getRESTHeaderParamName()»", «EXPAND HeaderParamValueAccessor FOR headerParam»);
			«IF headerParam.type.isPrimitiveType() == false»
			}
			else {
			lRequestBuilder.setHeader("«headerParam.getRESTHeaderParamName()»", null);
			}
			«ENDIF»
		«ENDFOREACH»
		«ENDIF»

    	«FOREACH this.getBeanParams() AS beanParam»
    		«IF beanParam.type.getAllAttributesFromHierarchy().typeSelect(JMM::HeaderParam).size > 0»
    		if(«beanParam.name» != null) {
    		«ENDIF»
    		«FOREACH beanParam.type.getAllAttributesFromHierarchy().typeSelect(JMM::HeaderParam) AS headerParam»
				«IF headerParam.type.isPrimitiveType() == false»
				if («beanParam.name».«headerParam.asGetter()»() != null) {
				«ENDIF»
		    	lRequestBuilder.setHeader("«headerParam.getRESTHeaderParamName()»", «EXPAND HeaderParamValueAccessorForBeanParam(beanParam) FOR headerParam»);
				«IF headerParam.type.isPrimitiveType() == false»
				}
				else {
				lRequestBuilder.setHeader("«headerParam.getRESTHeaderParamName()»", null);
				}
				«ENDIF»
    		«ENDFOREACH»
    		«IF beanParam.type.getAllAttributesFromHierarchy().typeSelect(JMM::HeaderParam).size > 0»
    		}
    		«ENDIF»
    	«ENDFOREACH»
    	
    	«IF this.hasCookieParams()»
	    	// Handle cookie parameters
	    	«FOREACH this.getCookieParams() AS cookieParam»
	    	«IF cookieParam.type.isPrimitiveType() == false»
			if («cookieParam.name» != null) {
			«ENDIF»
			lRequestBuilder.setCookie("«cookieParam.getRESTCookieParamName()»", «EXPAND CookieParamValueAccessor FOR cookieParam»);
	    	«IF cookieParam.type.isPrimitiveType() == false»
			}
			«ENDIF»
	    	«ENDFOREACH»
	    	
	    	«FOREACH this.getBeanParams() AS beanParam»
	    		«IF beanParam.type.getAllAttributesFromHierarchy().typeSelect(JMM::CookieParam).size > 0»
	    		if(«beanParam.name» != null) {
	    		«ENDIF»	    		
	    		«FOREACH beanParam.type.getAllAttributesFromHierarchy().typeSelect(JMM::CookieParam) AS cookieParam»
					«IF cookieParam.type.isPrimitiveType() == false»
					if («beanParam.name».«cookieParam.asGetter()»() != null) {
					«ENDIF»
					lRequestBuilder.setCookie("«cookieParam.getRESTCookieParamName()»", «EXPAND CookieParamValueAccessorForBeanParam(beanParam) FOR cookieParam»);
					«IF cookieParam.type.isPrimitiveType() == false»
					}
					«ENDIF»
	    		«ENDFOREACH»
	    		«IF beanParam.type.getAllAttributesFromHierarchy().typeSelect(JMM::CookieParam).size > 0»
	    		}
	    		«ENDIF»	    		
	    	«ENDFOREACH»
    	«ENDIF»
	    
	    «FOREACH this.getRequestBodyParameters() AS body»
	    // Set parameter «body.name» as request body.
	    lRequestBuilder.setBody(«body.name»);
	    «ENDFOREACH»

		«IF getReturnTypeName() != "void"»
		// Execute request and return result.
		«ELSE»
		// Execute request.
		«ENDIF»
		com.anaptecs.jeaf.rest.executor.api.RESTRequest lRequest = lRequestBuilder.build();
		
		«IF getReturnTypeName() != "void"»
			«IF this.getReturnResult().isMultivalued() == false»
			return requestExecutor.executeSingleObjectResultRequest(lRequest, «this.getHTTPStatusCode()», «this.getReturnResult().type.fqn()».class);
			«ELSE»
		    «getReturnTypeName()» lResult = requestExecutor.executeCollectionResultRequest(lRequest, «this.getHTTPStatusCode()», «this.getReturnResult().getCollectionType()».class, «this.getReturnResult().type.fqn()».class);
		    if (lResult == null) {
		      lResult = «this.getReturnResult().getEmptyCollectionOperation()»;
		    }
		    return lResult;
			«ENDIF»
		«ELSE»
		    requestExecutor.executeNoResultRequest(lRequest, «this.getHTTPStatusCode()»);
		«ENDIF»
	}
«ENDDEFINE»



«DEFINE HeaderParamValueAccessor FOR HeaderParam»
	«IF type.isStringType()»
		«name»
	«ELSE»
		«IF type.isPrimitiveType()»
			String.valueOf(«name»)
		«ELSE»
			«IF type.isOpenAPIDataType()»
				«name».«type.getAllAttributesFromHierarchy().first().asGetter()»()
			«ELSE»
				«IF isTargetRuntimeJEAF()»
				com.anaptecs.jeaf.xfun.api.XFun.getDatatypeConverterRegistry().getConverter(«type.fqn()».class, String.class).convert(«name»)
				«ENDIF»
				«IF isTargetRuntimeSpring()»
				«IF type.isAnyDateType()»
				«EXPAND DateConversion FOR this»
				«ELSE»
				«name».toString()
				«ENDIF»
				«ENDIF»
			«ENDIF»
		«ENDIF»
	«ENDIF»
«ENDDEFINE»

«DEFINE HeaderParamValueAccessorForBeanParam(uml::Parameter beanParam) FOR HeaderParam»
	«IF type.fqn() == "java.lang.String" || type.fqn() == "String"»
		«beanParam.name».«this.asGetter()»()
	«ELSE»
		«IF type.isPrimitiveType()»
			String.valueOf(«beanParam.name».«this.asGetter()»())
		«ELSE»
			«IF type.isOpenAPIDataType()»
				«beanParam.name».«this.asGetter()»().«type.getAllAttributesFromHierarchy().first().asGetter()»()
			«ELSE»
				«IF isTargetRuntimeJEAF()»
				com.anaptecs.jeaf.xfun.api.XFun.getDatatypeConverterRegistry().getConverter(«type.fqn()».class, String.class).convert(«beanParam.name».«this.asGetter()»())
				«ENDIF»
				«IF isTargetRuntimeSpring()»
				«IF type.isAnyDateType()»
				«EXPAND DateConversionForBeanParam(beanParam) FOR this»
				«ELSE»
				«beanParam.name».«this.asGetter()»().toString()
				«ENDIF»
				«ENDIF»
			«ENDIF»
		«ENDIF»
	«ENDIF»
«ENDDEFINE»

«DEFINE CookieParamValueAccessor FOR CookieParam»
	«IF type.fqn() == "java.lang.String"»
		«name»
	«ELSE»
		«IF type.isPrimitiveType()»
			String.valueOf(«name»)
		«ELSE»
			«IF type.isOpenAPIDataType()»
				«name».«type.getAllAttributesFromHierarchy().first().asGetter()»()
			«ELSE»
				«IF isTargetRuntimeJEAF()»
				com.anaptecs.jeaf.xfun.api.XFun.getDatatypeConverterRegistry().getConverter(«type.fqn()».class, String.class).convert(«name»)
				«ENDIF»
				«IF isTargetRuntimeSpring()»
				«IF type.isAnyDateType()»
				«EXPAND DateConversion FOR this»
				«ELSE»
				«name».toString()
				«ENDIF»
				«ENDIF»
			«ENDIF»
		«ENDIF»
	«ENDIF»
«ENDDEFINE»

«DEFINE CookieParamValueAccessorForBeanParam(uml::Parameter beanParam) FOR CookieParam»
	«IF type.fqn() == "java.lang.String"»
		«beanParam.name».«this.asGetter()»()
	«ELSE»
		«IF type.isPrimitiveType()»
			String.valueOf(«beanParam.name».«this.asGetter()»())
		«ELSE»
			«IF type.isOpenAPIDataType()»
				«beanParam.name».«this.asGetter()»().«type.getAllAttributesFromHierarchy().first().asGetter()»()
			«ELSE»
				«IF isTargetRuntimeJEAF()»
				com.anaptecs.jeaf.xfun.api.XFun.getDatatypeConverterRegistry().getConverter(«type.fqn()».class, String.class).convert(«beanParam.name».«this.asGetter()»())
				«ENDIF»
				«IF isTargetRuntimeSpring()»
				«IF type.isAnyDateType()»
				«EXPAND DateConversionForBeanParam(beanParam) FOR this»
				«ELSE»
				«beanParam.name».«this.asGetter()»().toString()
				«ENDIF»
				«ENDIF»
			«ENDIF»
		«ENDIF»
	«ENDIF»
«ENDDEFINE»

«DEFINE DateConversion FOR Parameter»
«IF type.isOffsetDateTime()»
java.time.format.DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(«this.name»)

«ELSE»«IF type.isOffsetTime()»
java.time.format.DateTimeFormatter.ISO_OFFSET_TIME.format(«this.name»)

«ELSE»«IF type.isLocalDateTime()»
java.time.format.DateTimeFormatter.ISO_DATE_TIME.format(«this.name»)

«ELSE»«IF type.isLocalTime()»
java.time.format.DateTimeFormatter.ISO_TIME.format(«this.name»)

«ELSE»«IF type.isLocalDate()»
java.time.format.DateTimeFormatter.ISO_DATE.format(«this.name»)

«ELSE»«IF type.isCalendar()»
new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX").format(«this.name».getTime())

«ELSE»«IF type.isUtilDate()»
new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX").format(«this.name»)

«ELSE»«IF type.isSQLTimestamp()»
new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX").format(«this.name»)

«ELSE»«IF type.isSQLTime()»
new java.text.SimpleDateFormat("HH:mm:ss.SSSXXX").format(«this.name»)

«ELSE»«IF type.isSQLDate()»
new java.text.SimpleDateFormat("yyyy-MM-dd").format(«this.name»)
«ENDIF»«ENDIF»«ENDIF»«ENDIF»«ENDIF»«ENDIF»«ENDIF»«ENDIF»«ENDIF»«ENDIF»
«ENDDEFINE»


«DEFINE DateConversionForBeanParam(uml::Parameter beanParam) FOR Property»
«IF type.isOffsetDateTime()»
java.time.format.DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(«beanParam.name».«this.asGetter()»())

«ELSE»«IF type.isOffsetTime()»
java.time.format.DateTimeFormatter.ISO_OFFSET_TIME.format(«beanParam.name».«this.asGetter()»())

«ELSE»«IF type.isLocalDateTime()»
java.time.format.DateTimeFormatter.ISO_DATE_TIME.format(«beanParam.name».«this.asGetter()»())

«ELSE»«IF type.isLocalTime()»
java.time.format.DateTimeFormatter.ISO_TIME.format(«beanParam.name».«this.asGetter()»())

«ELSE»«IF type.isLocalDate()»
java.time.format.DateTimeFormatter.ISO_DATE.format(«beanParam.name».«this.asGetter()»())

«ELSE»«IF type.isCalendar()»
new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX").format(«beanParam.name».«this.asGetter()»().getTime())

«ELSE»«IF type.isUtilDate()»
new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX").format(«beanParam.name».«this.asGetter()»())

«ELSE»«IF type.isSQLTimestamp()»
new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX").format(«beanParam.name».«this.asGetter()»())

«ELSE»«IF type.isSQLTime()»
new java.text.SimpleDateFormat("HH:mm:ss.SSSXXX").format(«beanParam.name».«this.asGetter()»())

«ELSE»«IF type.isSQLDate()»
new java.text.SimpleDateFormat("yyyy-MM-dd").format(«beanParam.name».«this.asGetter()»())
«ENDIF»«ENDIF»«ENDIF»«ENDIF»«ENDIF»«ENDIF»«ENDIF»«ENDIF»«ENDIF»«ENDIF»
«ENDDEFINE»


«DEFINE GenerateRESTServiceProxyConfigFile FOR RESTResource»
  «IF isTargetRuntimeSpring()»
  	«EXPAND GenerateRESTServiceProxyConfigFileSpring»
  «ENDIF» 
  «IF isTargetRuntimeJEAF()»
    «EXPAND GenerateRESTServiceProxyConfigFileJEAF»
  «ENDIF»
«ENDDEFINE»

«DEFINE GenerateRESTServiceProxyConfigFileSpring FOR RESTResource»
«FILE "config/application-"+name.toLowerCase()+".yml" res»
# File contains configuration for external REST resource «this.name»
# URL to external service
externalServiceURL: TODO: Please configure URL of external REST resource

«IF this.usesCookies() -»
# Domain of the cookie that is used in requests.
cookieDomain:

# Path of the cookie that is used in requests.
cookiePath:
«ENDIF -»

# Comma separated list of http header names that should be considered to be sensitive.
sensitiveHeaders: 
 - Authorzation

# Parameter defines if http requests should be traced.
traceRequests: true

# Parameter defines if http responses should be traced.
traceResponses: false

# Apache HTTP Client configuration
httpClientConfiguration:
  # Maximum size of the connection pool.
  maxPoolSize: 5
  
  # Maximum amount of idle connections in the connection pool.
  maxIdleConnections: 5
  
  # Keep alive duration for connection to proxy target (in milliseconds)
  keepAliveDuration: 20000
  
  #  Parameter configures the time period in milliseconds after which a connection is validated before it is taken 
  # from the pool again.    
  validateAfterInactivityDuration: 10000
  
  # Maximum amount of retries before a call to the REST service is considered to be failed.
  # Be aware that in case of enabled retires server side must support idempotency on writes.
  maxRetries: 0
  
  # Interval in milliseconds after which the REST service is called again in case that retries are configured.
  retryInterval: 100
  
  # Response timeout in milliseconds for calls to REST service. Please be aware that this is a very sensitive 
  # parameter and needs to be fine-tuned for your purposes.
  responseTimeout: 5000
  
  # Timeout in milliseconds to establish connections to the REST service. As connections are pooled this parameter
  # should not have a too strong influence on the overall behavior. However please ensure that it fits to your
  # environment.
  connectTimeout: 2000
   
  # Timeout in milliseconds when requesting a connection from the pool of http connections. This parameter especially
  # becomes important in cases where a connection pool is configured too small or in cases of unexpected high load.
  connectionRequestTimeout: 100

# Resilience4J circuit breaker configuration
circuitBreakerConfiguration:
  # Failure rate threshold (percent of requests) defines which amount of failed request must be exceeded due to
  # technical problems that the circuit breaker opens and no further request will be sent to the REST service.
  #  
  # Value must between 0 and 100.
  failureRateThreshold: 5
  
  # Duration in milliseconds that the circuit breaker stays open until request will be sent to the REST service again.
  # 
  # The value must be zero or greater.
  durationInOpenState: 20000
  
  # Configures the duration in milliseconds above which calls are considered as slow and increase the slow calls
  # percentage.
  # 
  # The value must be zero or greater.
  slowRequestDuration: 5000
  
  # Configures the slow request threshold in percentage. The circuit breaker considers a call as slow when the call
  # duration is greater than <code>slowCallDuration</code>. When the percentage of slow calls is equal to or greater
  # than the threshold, the circuit breaker transitions to open and starts short-circuiting calls.
  # 
  # Value must between 0 and 100.
  slowRequestRateThreshold: 30
  
  # Configures the number of permitted calls when the circuit breaker is half open.
  # 
  # The value must be zero or greater.
  permittedCallsInHalfOpenState: 2
  
  # Configures the size of the sliding window in seconds which is used to record the outcome of calls when the circuit
  # breaker is closed.
  # 
  # The value must be greater than 0.
  slidingWindowSizeSeconds: 5
«ENDFILE»
«ENDDEFINE»

«DEFINE GenerateRESTServiceProxyConfigFileJEAF FOR RESTResource»
«FILE name.toLowerCase()+"-rest-client.properties" res-»
#
# File contains configuration for external REST resource «this.name»
#

# URL to external service
externalServiceURL=Please configure URL of external REST resource
  
«IF this.usesCookies() -»
# Domain of the cookie that is used in requests.
cookieDomain=
  
# Path of the cookie that is used in requests.
cookiePath=
«ENDIF -»
  
# Comma separated list of http header names that should be considered to be sensitive.
sensitiveHeaders=Authorzation
  
# Parameter defines if http requests should be traced.
traceRequests=true

# Parameter defines if http responses should be traced.
traceResponses=false

#
# Apache HTTP Client configuration
#

# Maximum size of the connection pool.
maxPoolSize=5

# Maximum amount of idle connections in the connection pool.
maxIdleConnections=5

# Keep alive duration for connection to proxy target (in milliseconds)
keepAliveDuration=20000

#  Parameter configures the time period in milliseconds after which a connection is validated before it is taken 
# from the pool again.    
validateAfterInactivityDuration=10000

# Maximum amount of retries before a call to the REST service is considered to be failed.
# Be aware that in case of enabled retires server side must support idempotency on writes.
maxRetries=0

# Interval in milliseconds after which the REST service is called again in case that retries are configured.
retryInterval=100

# Response timeout in milliseconds for calls to REST service. Please be aware that this is a very sensitive 
# parameter and needs to be fine-tuned for your purposes.
responseTimeout=5000

# Timeout in milliseconds to establish connections to the REST service. As connections are pooled this parameter
# should not have a too strong influence on the overall behavior. However please ensure that it fits to your
# environment.
connectTimeout=2000

# Timeout in milliseconds when requesting a connection from the pool of http connections. This parameter especially
# becomes important in cases where a connection pool is configured too small or in cases of unexpected high load.
connectionRequestTimeout: 100

#
# Resilience4J circuit breaker configuration
#

# Failure rate threshold (percent of requests) defines which amount of failed request must be exceeded due to
# technical problems that the circuit breaker opens and no further request will be sent to the REST service.
#  
# Value must between 0 and 100.
failureRateThreshold=5
    
# Duration in milliseconds that the circuit breaker stays open until request will be sent to the REST service again.
# 
# The value must be zero or greater.
durationInOpenState=20000

# Configures the duration in milliseconds above which calls are considered as slow and increase the slow calls
# percentage.
# 
# The value must be zero or greater.
slowRequestDuration=5000

# Configures the slow request threshold in percentage. The circuit breaker considers a call as slow when the call
# duration is greater than <code>slowCallDuration</code>. When the percentage of slow calls is equal to or greater
# than the threshold, the circuit breaker transitions to open and starts short-circuiting calls.
# 
# Value must between 0 and 100.
slowRequestRateThreshold=30

# Configures the number of permitted calls when the circuit breaker is half open.
# 
# The value must be zero or greater.
permittedCallsInHalfOpenState=2

# Configures the size of the sliding window in seconds which is used to record the outcome of calls when the circuit
# breaker is closed.
# 
# The value must be greater than 0.
slidingWindowSizeSeconds=5
«ENDFILE»
«ENDDEFINE»